<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FantasyFolio</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --bg-card: rgba(255,255,255,0.05);
      --text-primary: #e4e4e4;
      --text-secondary: #888;
      --accent: #4dabf7;
      --accent-hover: #74c0fc;
      --border: rgba(255,255,255,0.1);
    }
    
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      color: var(--text-primary);
    }
    
    /* Layout */
    .app {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    
    .app-body {
      display: flex;
      flex: 1;
      overflow: hidden;
      height: 0; /* Force flex to calculate height */
    }
    
    /* Header */
    header {
      background: rgba(0,0,0,0.3);
      padding: 16px 24px;
      display: flex;
      align-items: center;
      gap: 24px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    
    .logo {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--accent);
    }
    
    .content-toggle {
      display: flex;
      gap: 4px;
      background: var(--bg-card);
      padding: 4px;
      border-radius: 8px;
    }
    
    .toggle-btn {
      padding: 8px 16px;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    
    .toggle-btn:hover {
      color: var(--text-primary);
    }
    
    .toggle-btn.active {
      background: var(--accent);
      color: white;
    }
    
    .settings-btn {
      background: transparent;
      border: none;
      font-size: 1.4rem;
      cursor: pointer;
      padding: 8px;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    
    .settings-btn:hover {
      opacity: 1;
    }
    
    .settings-btn {
      position: relative;
    }
    
    .trash-badge {
      position: absolute;
      top: 2px;
      right: 2px;
      background: #e74c3c;
      color: white;
      font-size: 0.65rem;
      font-weight: bold;
      min-width: 16px;
      height: 16px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 4px;
    }
    
    .search-box {
      flex: 1;
      max-width: 600px;
    }
    
    .search-box input {
      width: 100%;
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-primary);
      font-size: 1rem;
    }
    
    .search-box input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .adv-search-toggle {
      padding: 10px 14px;
      border-radius: 0 8px 8px 0;
      border: 1px solid var(--border);
      border-left: none;
      background: var(--bg-card);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
    }
    
    .adv-search-toggle:hover,
    .adv-search-toggle.active {
      background: var(--accent);
      color: white;
    }
    
    .search-box input {
      border-radius: 8px 0 0 8px;
    }
    
    .search-box {
      display: flex;
    }
    
    .stats {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    /* Advanced Search Panel */
    .advanced-search-panel {
      display: none;
      background: rgba(0,0,0,0.3);
      padding: 16px 24px;
      border-bottom: 1px solid var(--border);
      position: relative;
    }
    
    .advanced-search-panel.open {
      display: block;
    }
    
    .adv-search-close {
      position: absolute;
      top: 12px;
      right: 16px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    .adv-search-close:hover {
      color: #e74c3c;
      background: rgba(231,76,60,0.1);
    }
    
    .adv-search-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-bottom: 12px;
      align-items: center;
    }
    
    .adv-search-row:last-child {
      margin-bottom: 0;
    }
    
    .adv-search-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .adv-search-group label {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    .adv-search-group select,
    .adv-search-group input[type="number"] {
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-primary);
      font-size: 0.85rem;
    }
    
    .adv-search-group input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }
    
    .adv-search-terms {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 12px;
    }
    
    .adv-term-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(255,255,255,0.03);
      border-radius: 6px;
    }
    
    .term-label {
      font-size: 0.85rem;
      color: var(--text-secondary);
      min-width: 50px;
    }
    
    .term-operator {
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--accent);
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .term-include {
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-primary);
      font-size: 0.85rem;
    }
    
    .term-input {
      flex: 1;
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-primary);
      font-size: 0.9rem;
    }
    
    .term-remove {
      padding: 4px 8px;
      border-radius: 4px;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 1rem;
    }
    
    .term-remove:hover {
      color: #e74c3c;
    }
    
    .btn-add-term {
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px dashed var(--border);
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.85rem;
    }
    
    .btn-add-term:hover {
      border-color: var(--accent);
      color: var(--accent);
    }
    
    .btn-apply {
      padding: 8px 16px;
      border-radius: 4px;
      border: none;
      background: var(--accent);
      color: white;
      cursor: pointer;
      font-size: 0.85rem;
    }
    
    .btn-clear {
      padding: 8px 16px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.85rem;
    }
    
    .btn-clear:hover {
      border-color: #e74c3c;
      color: #e74c3c;
    }
    
    /* Sidebar */
    .sidebar {
      background: rgba(0,0,0,0.2);
      padding: 20px;
      overflow: auto;
      width: 300px;
      min-width: 150px;
      flex-shrink: 0;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) rgba(255,255,255,0.1);
    }
    
    .sidebar::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    
    .sidebar::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.1);
      border-radius: 5px;
    }
    
    .sidebar::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 5px;
    }
    
    .resize-handle {
      width: 8px;
      background: rgba(255,255,255,0.1);
      cursor: col-resize;
      transition: background 0.2s;
      flex-shrink: 0;
    }
    
    .resize-handle:hover,
    .resize-handle.dragging {
      background: var(--accent);
    }
    
    .folder-tree {
      margin-bottom: 24px;
    }
    
    /* Main Content - defined below */
    
    .sidebar h3 {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    
    .folder-list, .publisher-list {
      list-style: none;
      margin-bottom: 24px;
    }
    
    .folder-list li, .publisher-list li {
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s;
    }
    
    .folder-list li:hover, .publisher-list li:hover {
      background: var(--bg-card);
    }
    
    .folder-list li.active, .publisher-list li.active {
      background: var(--accent);
      color: white;
    }
    
    /* Tree structure */
    .folder-tree {
      list-style: none;
      margin-bottom: 24px;
      font-size: 0.85rem;
    }
    
    .tree-item {
      padding: 5px 8px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: background 0.2s;
      white-space: nowrap;
    }
    
    .tree-item:hover {
      background: var(--bg-card);
    }
    
    .tree-item.active {
      background: var(--accent);
      color: white;
    }
    
    .tree-item .toggle {
      width: 16px;
      text-align: center;
      font-size: 0.7rem;
      color: var(--text-secondary);
      flex-shrink: 0;
    }
    
    .tree-item.active .toggle {
      color: rgba(255,255,255,0.7);
    }
    
    .tree-item .folder-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .tree-children {
      display: none;
    }
    
    .tree-children.expanded {
      display: block;
      min-width: max-content;
    }
    
    .count-badge {
      background: var(--bg-card);
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 0.7rem;
      color: var(--text-secondary);
      flex-shrink: 0;
    }
    
    .active .count-badge {
      background: rgba(255,255,255,0.2);
      color: white;
    }
    
    /* Main Content */
    .main {
      padding: 24px;
      padding-bottom: 0;
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .view-controls {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
      flex-shrink: 0;
    }
    
    .main-scroll {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding-bottom: 24px;
      min-height: 0; /* Required for flex child to scroll */
    }
    
    .view-btn {
      padding: 8px 16px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      font-size: 0.85rem;
    }
    
    .view-btn.active {
      background: var(--accent);
      border-color: var(--accent);
    }
    
    .sort-controls {
      display: flex;
      gap: 8px;
      margin-left: auto;
    }
    
    .sort-controls select {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #fff;
      color: #222;
      font-size: 0.85rem;
      cursor: pointer;
      color-scheme: light;
    }
    
    .sort-controls select option {
      background: #fff;
      color: #222;
    }
    
    .clear-btn {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-secondary);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .clear-btn:hover {
      background: #e74c3c;
      border-color: #e74c3c;
      color: white;
    }
    
    /* Grid View */
    .asset-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 20px;
    }
    
    .asset-card {
      background: var(--bg-card);
      border-radius: 10px;
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .asset-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }
    
    .asset-thumb {
      width: 100%;
      aspect-ratio: 3/4;
      object-fit: cover;
      background: var(--bg-secondary);
    }
    
    .asset-info {
      padding: 12px;
    }
    
    .asset-title {
      font-size: 0.85rem;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 4px;
    }
    
    .asset-meta {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }
    
    /* List View */
    .asset-list {
      display: none;
    }
    
    .asset-list.active {
      display: block;
    }
    
    .asset-grid.hidden {
      display: none;
    }
    
    .asset-row {
      display: grid;
      grid-template-columns: 60px 1fr 150px 100px 80px;
      gap: 16px;
      padding: 12px;
      background: var(--bg-card);
      border-radius: 8px;
      margin-bottom: 8px;
      align-items: center;
      cursor: pointer;
    }
    
    .asset-row:hover {
      background: rgba(255,255,255,0.08);
    }
    
    .asset-row img {
      width: 60px;
      height: 80px;
      object-fit: cover;
      border-radius: 4px;
    }
    
    .asset-row .title {
      font-weight: 500;
    }
    
    .asset-row .publisher {
      color: var(--text-secondary);
      font-size: 0.85rem;
    }
    
    .asset-row .pages, .asset-row .size {
      color: var(--text-secondary);
      font-size: 0.85rem;
      text-align: right;
    }
    
    /* Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    
    .modal-overlay.active {
      display: flex;
    }
    
    .modal {
      background: var(--bg-secondary);
      border-radius: 12px;
      max-width: 800px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }
    
    .modal-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 1.5rem;
      cursor: pointer;
    }
    
    .modal-body {
      display: grid;
      grid-template-columns: 200px 1fr;
      gap: 24px;
      padding: 24px;
    }
    
    .modal-thumb {
      width: 100%;
      border-radius: 8px;
    }
    
    .modal-details h2 {
      margin-bottom: 16px;
      font-size: 1.4rem;
    }
    
    .detail-row {
      display: flex;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
    }
    
    .detail-label {
      width: 120px;
      color: var(--text-secondary);
      font-size: 0.85rem;
    }
    
    .detail-value {
      flex: 1;
      font-size: 0.9rem;
    }
    
    .breadcrumbs {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 4px;
    }
    
    .breadcrumb-link {
      color: var(--accent);
      text-decoration: none;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.85rem;
      transition: background 0.2s;
    }
    
    .breadcrumb-link:hover {
      background: var(--accent);
      color: white;
    }
    
    .breadcrumb-sep {
      color: var(--text-secondary);
      font-size: 0.8rem;
    }
    
    .modal-actions {
      display: flex;
      gap: 12px;
      margin-top: 20px;
    }
    
    .btn {
      padding: 10px 20px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
    }
    
    .btn-primary {
      background: var(--accent);
      color: white;
    }
    
    .btn-secondary {
      background: var(--bg-card);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }
    
    /* Page Extraction */
    .page-extract-section {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    
    .page-extract-section h4 {
      font-size: 0.95rem;
      margin-bottom: 12px;
      color: var(--text-primary);
    }
    
    .page-extract-row {
      display: flex;
      gap: 8px;
    }
    
    .page-input {
      flex: 1;
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-primary);
      font-size: 0.9rem;
    }
    
    .page-extract-hint {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: 6px;
    }
    
    /* Search Matches in Detail Modal */
    .search-matches-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    
    .search-matches-section h4 {
      font-size: 0.95rem;
      margin-bottom: 12px;
      color: var(--accent);
    }
    
    .search-matches-list {
      max-height: 250px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .search-matches-list .page-match {
      display: flex;
      gap: 10px;
      padding: 10px;
      background: rgba(77, 171, 247, 0.1);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      align-items: flex-start;
      border: 1px solid transparent;
    }
    
    .search-matches-list .page-match:hover {
      background: var(--accent);
      border-color: var(--accent);
    }
    
    .search-matches-list .page-num {
      background: var(--accent);
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 600;
      flex-shrink: 0;
    }
    
    .search-matches-list .page-match:hover .page-num {
      background: white;
      color: var(--accent);
    }
    
    .search-matches-list .snippet {
      color: var(--text-secondary);
      line-height: 1.4;
    }
    
    .search-matches-list .snippet mark {
      background: rgba(77, 171, 247, 0.3);
      color: var(--text-primary);
      padding: 0 2px;
      border-radius: 2px;
    }
    
    /* Bookmarks/TOC */
    .bookmarks-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    
    .bookmarks-section h4 {
      font-size: 0.95rem;
      margin-bottom: 8px;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .bookmarks-section h4:hover {
      color: var(--accent);
    }
    
    .bookmarks-list {
      max-height: 300px;
      overflow-y: auto;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
      padding: 8px;
    }
    
    .bookmark-item {
      padding: 6px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .bookmark-item:hover {
      background: var(--bg-card);
    }
    
    .bookmark-title {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .bookmark-page {
      color: var(--text-secondary);
      font-size: 0.75rem;
      margin-left: 8px;
    }
    
    .bookmark-level-1 { padding-left: 0; }
    .bookmark-level-2 { padding-left: 16px; }
    .bookmark-level-3 { padding-left: 32px; }
    .bookmark-level-4 { padding-left: 48px; }
    
    .bookmarks-empty {
      color: var(--text-secondary);
      font-size: 0.85rem;
      padding: 12px;
      text-align: center;
    }
    
    /* Content Search Results */
    .content-results {
      margin-bottom: 24px;
      background: var(--bg-card);
      border-radius: 10px;
      padding: 16px;
    }
    
    .content-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 20px;
    }
    
    .content-grid.hidden {
      display: none;
    }
    
    .content-list.hidden {
      display: none;
    }
    
    .content-results h3 {
      font-size: 1rem;
      margin-bottom: 16px;
      color: var(--accent);
    }
    
    .content-results-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .content-result-card {
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      padding: 12px;
    }
    
    .content-result-header {
      display: flex;
      gap: 12px;
      cursor: pointer;
      margin-bottom: 10px;
    }
    
    .content-result-header img {
      width: 50px;
      height: 65px;
      object-fit: cover;
      border-radius: 4px;
    }
    
    .content-result-header .title {
      font-weight: 500;
      margin-bottom: 4px;
    }
    
    .content-result-header .path {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }
    
    .page-matches {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-left: 62px;
    }
    
    .page-match {
      display: flex;
      gap: 10px;
      padding: 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
      align-items: flex-start;
    }
    
    .page-match:hover {
      background: var(--accent);
    }
    
    .page-num {
      background: var(--accent);
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.75rem;
      font-weight: 600;
      flex-shrink: 0;
    }
    
    .page-match:hover .page-num {
      background: white;
      color: var(--accent);
    }
    
    .snippet {
      color: var(--text-secondary);
      line-height: 1.4;
    }
    
    .snippet mark {
      background: rgba(77, 171, 247, 0.3);
      color: var(--text-primary);
      padding: 0 2px;
      border-radius: 2px;
    }
    
    .more-pages {
      font-size: 0.8rem;
      color: var(--text-secondary);
      padding: 4px 8px;
    }
    
    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }
    
    .empty-state h3 {
      margin-bottom: 8px;
      color: var(--text-primary);
    }
    
    /* 3D Model Icons */
    .model-icon {
      font-size: 4rem;
      text-align: center;
      padding: 20px;
      background: var(--bg-card);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 140px;
    }
    
    .model-icon-small {
      font-size: 1.5rem;
      width: 40px;
      text-align: center;
    }
    
    .model-preview-icon {
      font-size: 6rem;
      text-align: center;
      padding: 30px;
      background: var(--bg-card);
      border-radius: 8px;
    }
    
    /* 3D Model Preview in Modal */
    .model-preview-area {
      position: relative;
    }
    
    .model-thumb-img {
      width: 100%;
      max-width: 200px;
      height: auto;
      border-radius: 8px;
      background: var(--bg-card);
    }
    
    .model-thumb-fallback {
      width: 200px;
      height: 200px;
      font-size: 4rem;
      background: var(--bg-card);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* 3D Viewer */
    .viewer-3d {
      display: none;
      width: 200px;
      height: 200px;
      background: #1a1a2e;
      border-radius: 8px;
      overflow: hidden;
    }
    
    .viewer-controls {
      display: none;
      position: absolute;
      bottom: 8px;
      left: 8px;
      gap: 4px;
      z-index: 10;
    }
    
    .viewer-controls button {
      background: rgba(0,0,0,0.8);
      color: var(--text-primary);
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    
    .viewer-controls button:hover {
      background: var(--accent);
    }
    
    /* 3D Grid Thumbnail */
    .model-grid-thumb {
      object-fit: contain;
      background: var(--bg-card);
    }
    
    /* Collection list */
    .collection-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    .collection-list li {
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2px;
    }
    
    .collection-list li:hover {
      background: var(--bg-card);
    }
    
    .collection-list li.active {
      background: var(--accent);
      color: white;
    }
    
    /* Upload Modal */
    .upload-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      z-index: 3000;
      justify-content: center;
      align-items: center;
    }
    
    .upload-overlay.active {
      display: flex;
    }
    
    .upload-modal {
      background: var(--bg-secondary);
      border-radius: 12px;
      width: 90%;
      max-width: 600px;
      max-height: 85vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    .upload-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }
    
    .upload-header h2 {
      margin: 0;
      font-size: 1.3rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .upload-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 1.5rem;
      cursor: pointer;
    }
    
    .upload-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    
    .upload-section {
      margin-bottom: 20px;
    }
    
    .upload-section h3 {
      font-size: 0.95rem;
      margin-bottom: 12px;
      color: var(--accent);
    }
    
    .upload-path-display {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px;
      background: var(--bg-card);
      border-radius: 8px;
      margin-bottom: 12px;
    }
    
    .upload-path-display .path {
      flex: 1;
      font-family: monospace;
      font-size: 0.9rem;
      color: var(--accent);
      word-break: break-all;
    }
    
    .upload-folder-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 12px;
    }
    
    .upload-folder-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
    }
    
    .upload-folder-item:last-child {
      border-bottom: none;
    }
    
    .upload-folder-item:hover {
      background: var(--bg-card);
    }
    
    .upload-folder-item.parent {
      color: var(--text-secondary);
    }
    
    .upload-new-folder {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .upload-new-folder input {
      flex: 1;
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-primary);
      font-size: 0.9rem;
    }
    
    .upload-new-folder button {
      padding: 10px 16px;
      border-radius: 6px;
      border: none;
      background: var(--accent);
      color: white;
      cursor: pointer;
      white-space: nowrap;
    }
    
    .upload-dropzone {
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .upload-dropzone:hover,
    .upload-dropzone.dragover {
      border-color: var(--accent);
      background: rgba(77, 171, 247, 0.1);
    }
    
    .upload-dropzone-icon {
      font-size: 3rem;
      margin-bottom: 12px;
    }
    
    .upload-dropzone-text {
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    
    .upload-dropzone-hint {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    .upload-file-list {
      margin-top: 16px;
    }
    
    .upload-file-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--bg-card);
      border-radius: 6px;
      margin-bottom: 8px;
    }
    
    .upload-file-item .name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .upload-file-item .size {
      color: var(--text-secondary);
      font-size: 0.85rem;
    }
    
    .upload-file-item .remove {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 1.2rem;
      padding: 0 4px;
    }
    
    .upload-file-item .remove:hover {
      color: #e74c3c;
    }
    
    .upload-progress {
      margin-top: 12px;
      display: none;
    }
    
    .upload-progress.active {
      display: block;
    }
    
    .upload-progress-bar {
      height: 8px;
      background: var(--bg-card);
      border-radius: 4px;
      overflow: hidden;
    }
    
    .upload-progress-fill {
      height: 100%;
      background: var(--accent);
      width: 0%;
      transition: width 0.3s;
    }
    
    .upload-progress-text {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-top: 6px;
      text-align: center;
    }
    
    .upload-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-top: 1px solid var(--border);
    }
    
    .upload-footer .file-count {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }
    
    .upload-footer .buttons {
      display: flex;
      gap: 12px;
    }
    
    /* Settings Modal */
    .settings-overlay, .browser-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      z-index: 3000;
      justify-content: center;
      align-items: center;
    }
    
    .settings-overlay.active, .browser-overlay.active {
      display: flex;
    }
    
    .settings-modal {
      background: var(--bg-secondary);
      border-radius: 12px;
      width: 70%;
      max-width: 85%;
      min-width: 400px;
      height: 75vh;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      resize: both;
    }
    
    .settings-modal-large {
      width: 75%;
    }
    
    /* Settings Tabs */
    .settings-tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
      padding: 0 20px;
    }
    
    .settings-tab {
      padding: 12px 20px;
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.95rem;
      transition: all 0.2s;
    }
    
    .settings-tab:hover {
      color: var(--text);
    }
    
    .settings-tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }
    
    .settings-tab-content {
      display: block;
    }
    
    .settings-hint {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }
    
    /* Asset Locations */
    .asset-locations-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .location-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-primary);
      border-radius: 8px;
      border: 1px solid var(--border);
      position: relative;
    }
    
    .location-item.disabled {
      opacity: 0.6;
    }
    
    .location-icon {
      font-size: 1.5rem;
      width: 32px;
      text-align: center;
      flex-shrink: 0;
    }
    
    .location-info {
      flex: 1;
      min-width: 0;
    }
    
    .location-name {
      font-weight: 500;
      margin-bottom: 2px;
    }
    
    .location-path {
      font-size: 0.85rem;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .location-badges {
      display: flex;
      gap: 6px;
      margin-top: 4px;
    }
    
    .location-badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 4px;
      background: var(--bg-secondary);
    }
    
    .location-badge.documents {
      background: rgba(77, 171, 247, 0.2);
      color: #4dabf7;
    }
    
    .location-badge.models {
      background: rgba(190, 75, 219, 0.2);
      color: #be4bdb;
    }
    
    .location-badge.local { background: rgba(64, 192, 87, 0.2); color: #40c057; }
    .location-badge.local_mount { background: rgba(255, 212, 59, 0.2); color: #ffd43b; }
    .location-badge.remote_sftp { background: rgba(255, 107, 107, 0.2); color: #ff6b6b; }
    
    .location-actions {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    
    .location-actions button {
      padding: 6px 10px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
      white-space: nowrap;
    }
    
    .location-actions button:hover {
      background: var(--accent);
      color: white;
    }
    
    .location-actions button.action-test {
      background: rgba(64, 192, 87, 0.15);
      border-color: rgba(64, 192, 87, 0.4);
      color: #40c057;
    }
    
    .location-actions button.action-test:hover {
      background: #40c057;
      color: white;
    }
    
    .location-actions button.action-index {
      background: rgba(77, 171, 247, 0.15);
      border-color: rgba(77, 171, 247, 0.4);
      color: #4dabf7;
    }
    
    .location-actions button.action-index:hover {
      background: #4dabf7;
      color: white;
    }
    
    .location-actions button.action-remount {
      background: rgba(255, 212, 59, 0.15);
      border-color: rgba(255, 212, 59, 0.4);
      color: #ffd43b;
    }
    
    .location-actions button.action-remount:hover {
      background: #ffd43b;
      color: #1a1a2e;
    }
    
    /* Edit dropdown menu */
    .location-edit-wrapper {
      position: relative;
    }
    
    .location-edit-menu {
      display: none;
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 4px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      min-width: 160px;
      z-index: 100;
      overflow: hidden;
    }
    
    .location-edit-menu.open {
      display: block;
    }
    
    .location-edit-menu button {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      padding: 10px 14px;
      border: none;
      border-radius: 0;
      background: transparent;
      color: var(--text-primary);
      font-size: 0.9rem;
      text-align: left;
      cursor: pointer;
    }
    
    .location-edit-menu button:hover {
      background: var(--bg-card);
    }
    
    .location-edit-menu button.danger {
      color: #fa5252;
    }
    
    .location-edit-menu button.danger:hover {
      background: rgba(250, 82, 82, 0.15);
    }
    
    .location-edit-menu .menu-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }
    
    /* Delete confirmation overlay */
    .delete-confirm-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 4000;
      justify-content: center;
      align-items: center;
    }
    
    .delete-confirm-overlay.active {
      display: flex;
    }
    
    .delete-confirm-modal {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      text-align: center;
    }
    
    .delete-confirm-modal h3 {
      color: #fa5252;
      margin-bottom: 12px;
    }
    
    .delete-confirm-modal p {
      color: var(--text-secondary);
      margin-bottom: 20px;
    }
    
    .delete-confirm-modal .buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    
    .location-empty {
      padding: 20px;
      text-align: center;
      color: var(--text-secondary);
    }
    
    /* Add Location Modal */
    .add-location-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    
    .form-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .form-row label {
      font-size: 0.9rem;
      font-weight: 500;
    }
    
    .form-row input, .form-row select {
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-primary);
      color: var(--text);
      font-size: 0.95rem;
    }
    
    .form-row .input-with-btn {
      display: flex;
      gap: 8px;
    }
    
    .form-row .input-with-btn input {
      flex: 1;
    }
    
    /* SSH Key Options in Add Location */
    .ssh-key-options {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .ssh-key-select select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-primary);
      color: var(--text);
    }
    
    .ssh-key-path-row {
      display: flex;
      gap: 8px;
    }
    
    .ssh-key-path-row input {
      flex: 1;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-primary);
      color: var(--text);
    }
    
    .ssh-dam-key-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: var(--bg-primary);
      border-radius: 6px;
      border: 1px solid var(--border);
    }
    
    .dam-key-status {
      flex: 1;
      font-size: 0.9rem;
    }
    
    .dam-key-status .exists {
      color: #40c057;
    }
    
    .dam-key-status .not-exists {
      color: #ff6b6b;
    }
    
    .dam-key-status .loading {
      color: var(--text-secondary);
    }
    
    .ssh-key-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .ssh-key-item:last-child {
      border-bottom: none;
    }
    
    .ssh-key-item:hover {
      background: var(--bg-card);
    }
    
    .ssh-key-item.selected {
      background: rgba(77, 171, 247, 0.2);
      border-color: var(--accent);
    }
    
    .ssh-key-item .key-icon {
      font-size: 1.2rem;
    }
    
    .ssh-key-item .key-info {
      flex: 1;
    }
    
    .ssh-key-item .key-name {
      font-weight: 500;
    }
    
    .ssh-key-item .key-meta {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .ssh-key-item .key-badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(77, 171, 247, 0.2);
      color: var(--accent);
    }
    
    /* SSH Auth Method Options */
    .ssh-auth-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .ssh-auth-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .ssh-auth-option:hover {
      border-color: var(--accent);
    }
    
    .ssh-auth-option input[type="radio"] {
      width: 18px;
      height: 18px;
      margin: 0;
    }
    
    .ssh-auth-option input[type="radio"]:checked + span {
      color: var(--accent);
      font-weight: 500;
    }
    
    .ssh-auth-option.advanced {
      border-style: dashed;
      opacity: 0.8;
    }
    
    .ssh-auth-option.advanced:hover {
      opacity: 1;
    }
    
    .ssh-auth-panel {
      margin-top: 8px;
      padding: 10px;
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      border: 1px solid var(--border);
      max-height: 200px;
      overflow-y: auto;
    }
    
    /* Test Connection Button - prominent style */
    .btn-test-connection {
      padding: 10px 20px;
      background: linear-gradient(135deg, #3d7a4d 0%, #2d5a3d 100%);
      border: 2px solid #4d9a5d;
      border-radius: 6px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.95rem;
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .btn-test-connection:hover {
      background: linear-gradient(135deg, #4d9a5d 0%, #3d7a4d 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(61, 122, 77, 0.3);
    }
    
    .btn-test-connection:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .field-hint {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-top: 4px;
    }
    
    #locTestConnectionRow {
      flex-direction: row;
      align-items: center;
      gap: 12px;
    }
    
    .test-result {
      font-size: 0.9rem;
    }
    
    .test-result.success { color: #40c057; }
    .test-result.error { color: #ff6b6b; }
    .test-result.loading { color: var(--text-secondary); }
    
    .btn-sm {
      padding: 6px 10px;
      font-size: 0.85rem;
    }
    
    /* Journal controls */
    .journal-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    
    .journal-status {
      flex: 1;
      font-size: 0.9rem;
    }
    
    .journal-status .status-indicator {
      color: #40c057;
    }
    
    .journal-list, .snapshot-list {
      max-height: 250px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-top: 12px;
      display: none;
    }
    
    .journal-list.visible, .snapshot-list.visible {
      display: block;
    }
    
    .journal-entry, .snapshot-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      font-size: 0.9rem;
    }
    
    .journal-entry:last-child, .snapshot-item:last-child {
      border-bottom: none;
    }
    
    .journal-entry:hover, .snapshot-item:hover {
      background: var(--bg-primary);
    }
    
    .journal-action {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 500;
      text-transform: uppercase;
    }
    
    .journal-action.create { background: rgba(64, 192, 87, 0.2); color: #40c057; }
    .journal-action.trash { background: rgba(250, 82, 82, 0.2); color: #fa5252; }
    .journal-action.restore { background: rgba(77, 171, 247, 0.2); color: #4dabf7; }
    .journal-action.update { background: rgba(250, 176, 5, 0.2); color: #fab005; }
    
    .journal-entity {
      flex: 1;
      color: var(--text);
    }
    
    .journal-time {
      color: var(--text-secondary);
      font-size: 0.8rem;
    }
    
    .journal-empty, .snapshot-empty {
      padding: 20px;
      text-align: center;
      color: var(--text-secondary);
    }
    
    .journal-active {
      color: #40c057;
    }
    
    .snapshot-info {
      flex: 1;
    }
    
    .snapshot-name {
      font-weight: 500;
    }
    
    .snapshot-meta {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .snapshot-actions {
      display: flex;
      gap: 6px;
    }
    
    .snapshot-actions button {
      padding: 4px 8px;
      font-size: 0.8rem;
      border: 1px solid var(--border);
      background: var(--bg-primary);
      border-radius: 4px;
      cursor: pointer;
    }
    
    .snapshot-actions button:hover {
      background: var(--bg-secondary);
    }
    
    .restic-status {
      padding: 8px 0;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }
    
    .restic-status.error {
      color: #fa5252;
    }
    
    .restic-status.success {
      color: #40c057;
    }
    
    .restic-snapshots-panel {
      margin-top: 16px;
      padding: 16px;
      background: var(--bg-primary);
      border-radius: 8px;
      border: 1px solid var(--accent);
    }
    
    .restic-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    
    .restic-panel-header h4 {
      margin: 0;
      font-size: 1rem;
    }
    
    .btn-sm {
      padding: 4px 10px !important;
      font-size: 0.85rem;
    }
    
    /* Backup Policy Table */
    .policy-section {
      margin-bottom: 20px;
    }
    
    .policy-section h4 {
      margin: 0 0 10px 0;
      font-size: 0.95rem;
      color: var(--text-secondary);
    }
    
    .policy-table {
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      font-size: 0.85rem;
    }
    
    .policy-table-header {
      display: grid;
      grid-template-columns: 1.5fr 2fr 1fr 1.2fr 1.2fr 1fr 80px;
      gap: 8px;
      padding: 10px 12px;
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border);
      font-weight: 500;
      color: var(--text-secondary);
    }
    
    .policy-table-body {
      max-height: 200px;
      overflow-y: auto;
    }
    
    .policy-row {
      display: grid;
      grid-template-columns: 1.5fr 2fr 1fr 1.2fr 1.2fr 1fr 80px;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      align-items: center;
    }
    
    .policy-row:last-child {
      border-bottom: none;
    }
    
    .policy-row:hover {
      background: var(--bg-primary);
    }
    
    .policy-row .col-name {
      font-weight: 500;
    }
    
    .policy-row .col-dest {
      font-size: 0.8rem;
      color: var(--text-secondary);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .policy-row .col-dest .dest-type {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      margin-right: 4px;
    }
    
    .policy-row .col-dest .dest-type.local {
      background: rgba(64, 192, 87, 0.2);
      color: #40c057;
    }
    
    .policy-row .col-dest .dest-type.network {
      background: rgba(77, 171, 247, 0.2);
      color: #4dabf7;
    }
    
    .policy-row .col-dest .dest-type.restic {
      background: rgba(190, 75, 219, 0.2);
      color: #be4bdb;
    }
    
    .policy-row .snapshots-btn {
      background: rgba(190, 75, 219, 0.2);
      color: #be4bdb;
      border: 1px solid rgba(190, 75, 219, 0.4);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
    }
    
    .policy-row .snapshots-btn:hover {
      background: rgba(190, 75, 219, 0.4);
    }
    
    .policy-row .state-select {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-primary);
      color: var(--text);
      font-size: 0.8rem;
      cursor: pointer;
    }
    
    .policy-row .col-actions {
      display: flex;
      gap: 4px;
    }
    
    .policy-row .col-actions button {
      padding: 4px 6px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-primary);
      cursor: pointer;
      font-size: 0.85rem;
    }
    
    .policy-row .col-actions button:hover {
      background: var(--bg-secondary);
    }
    
    .policy-empty {
      padding: 20px;
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
    }
    
    /* Add Policy Form */
    .policy-add-section {
      margin-top: 20px;
      padding: 16px;
      background: var(--bg-primary);
      border-radius: 8px;
    }
    
    .policy-add-section h4 {
      margin: 0 0 12px 0;
      font-size: 0.95rem;
    }
    
    .policy-add-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .policy-input {
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-secondary);
      color: var(--text);
      font-size: 0.85rem;
    }
    
    .policy-input.name { width: 140px; }
    .policy-input.dest-type { width: 120px; }
    .policy-input.path { flex: 1; min-width: 180px; }
    .policy-input.ssh-host { width: 140px; }
    .policy-input.ssh-key { flex: 1; min-width: 180px; }
    .policy-input.frequency { width: 100px; }
    .policy-input.time { width: 100px; }
    .policy-input.date { width: 140px; }
    .policy-input.retention { width: 70px; text-align: center; }
    .policy-input.state { width: 100px; }
    .policy-input.restic-pw { width: 150px; }
    
    .path-input-wrapper {
      display: flex;
      flex: 1;
      min-width: 180px;
      gap: 4px;
    }
    
    .path-input-wrapper .policy-input.path {
      min-width: 120px;
    }
    
    .browse-btn {
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      cursor: pointer;
      font-size: 0.85rem;
      white-space: nowrap;
    }
    
    .browse-btn:hover {
      background: var(--accent);
      color: white;
    }
    
    /* Directory Browser Modal */
    .dir-browser-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3500;
    }
    
    .dir-browser-overlay.active {
      display: flex;
    }
    
    /* Directory browser needs higher z-index when opened from other modals */
    #dirBrowserModal {
      z-index: 3600 !important;
    }
    
    /* Settings modals get lower z-index so directory browser appears above */
    #addLocationModal,
    #sshKeyHelpModal {
      z-index: 3400 !important;
    }
    
    .dir-browser-modal {
      background: var(--bg-secondary);
      border-radius: 12px;
      width: 500px;
      max-width: 90%;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .dir-browser-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .dir-browser-header h3 {
      margin: 0;
      font-size: 1.1rem;
    }
    
    .dir-browser-path {
      padding: 12px 20px;
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border);
      font-family: monospace;
      font-size: 0.85rem;
      color: var(--text-secondary);
      word-break: break-all;
    }
    
    .dir-browser-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px 0;
    }
    
    .dir-browser-item {
      padding: 10px 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      transition: background 0.15s;
    }
    
    .dir-browser-item:hover {
      background: var(--bg-card);
    }
    
    .dir-browser-item.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .dir-browser-item .icon {
      font-size: 1.2rem;
    }
    
    .dir-browser-item .name {
      flex: 1;
      font-size: 0.9rem;
    }
    
    .dir-browser-item.parent-dir {
      color: var(--accent);
      font-weight: 500;
    }
    
    .dir-browser-empty {
      padding: 40px 20px;
      text-align: center;
      color: var(--text-secondary);
    }
    
    .dir-browser-newfolder {
      padding: 12px 20px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
    }
    
    .dir-browser-newfolder input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-primary);
      color: var(--text);
      font-size: 0.9rem;
    }
    
    .dir-browser-footer {
      padding: 16px 20px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      flex-shrink: 0;  /* Ensure footer doesn't shrink */
    }
    
    .policy-add-row .field-label {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    .policy-save-btn {
      padding: 8px 16px !important;
    }
    
    .policy-validation-msg {
      font-size: 0.85rem;
      padding: 8px 0;
      min-height: 20px;
    }
    
    .policy-validation-msg.error {
      color: #fa5252;
    }
    
    .policy-validation-msg.success {
      color: #40c057;
    }
    
    /* Backup subsections */
    .backup-subsection {
      margin-bottom: 20px;
      padding: 12px;
      background: var(--bg-primary);
      border-radius: 8px;
    }
    
    .backup-subsection h4 {
      margin: 0 0 12px 0;
      font-size: 0.95rem;
      font-weight: 500;
    }
    
    .snapshot-controls, .backup-policies {
      margin-bottom: 12px;
    }
    
    .snapshot-controls {
      display: flex;
      gap: 8px;
    }
    
    .snapshot-status {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    .policy-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
    }
    
    .policy-item:last-child {
      border-bottom: none;
    }
    
    .policy-name {
      font-weight: 500;
    }
    
    .policy-status {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }
    
    .trash-actions {
      margin-top: 12px;
      display: flex;
      gap: 8px;
    }
    
    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }
    
    .settings-header h2 {
      margin: 0;
      font-size: 1.3rem;
    }
    
    .settings-close, .browser-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 1.5rem;
      cursor: pointer;
    }
    
    .settings-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    
    .settings-section {
      margin-bottom: 24px;
    }
    
    .settings-section h3 {
      font-size: 1rem;
      margin-bottom: 12px;
      color: var(--accent);
    }
    
    .settings-field {
      margin-bottom: 16px;
    }
    
    .settings-field label {
      display: block;
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }
    
    .settings-field input, .settings-field textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-primary);
      font-size: 0.9rem;
    }
    
    .settings-field textarea {
      resize: vertical;
      font-family: monospace;
    }
    
    .path-input-row {
      display: flex;
      gap: 8px;
    }
    
    .path-input-row input {
      flex: 1;
    }
    
    .path-input-row button {
      padding: 10px 16px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      cursor: pointer;
    }
    
    .path-input-row button:hover {
      background: var(--accent);
      border-color: var(--accent);
    }
    
    .index-btn {
      padding: 10px 14px;
      background: #2d5a3d;
      border: 1px solid #3d7a4d;
      border-radius: 6px;
      color: white;
      cursor: pointer;
      font-size: 0.85rem;
      white-space: nowrap;
    }
    
    .index-btn:hover {
      background: #3d7a4d;
    }
    
    .index-btn.smb-index {
      margin-top: 8px;
      width: 100%;
    }
    
    .index-status {
      font-size: 0.8rem;
      margin-top: 6px;
      padding: 6px 10px;
      border-radius: 4px;
      display: none;
    }
    
    .index-status.active {
      display: block;
      background: rgba(77, 171, 247, 0.2);
      color: var(--accent);
    }
    
    .index-status.success {
      display: block;
      background: rgba(61, 122, 77, 0.2);
      color: #6fbf8a;
    }
    
    .index-status.error {
      display: block;
      background: rgba(200, 80, 80, 0.2);
      color: #e08080;
    }
    
    .index-status.info {
      display: block !important;
      background: rgba(77, 171, 247, 0.2);
      color: #4dabf7;
    }
    
    /* Suspended index button */
    .index-btn.suspended {
      background: rgba(250, 82, 82, 0.1);
      border-color: rgba(250, 82, 82, 0.3);
    }
    
    .suspended-badge {
      margin-left: 4px;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .index-status.suspended {
      color: #fab005;
      background: rgba(250, 176, 5, 0.1);
      padding: 8px 12px;
      border-radius: 4px;
      margin-top: 8px;
    }
    
    /* Toast notifications */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .toast {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 20px;
      border-radius: 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transform: translateX(120%);
      transition: transform 0.3s ease;
      max-width: 400px;
    }
    
    .toast.show {
      transform: translateX(0);
    }
    
    .toast-icon {
      font-size: 1.2rem;
    }
    
    .toast-message {
      color: var(--text);
      font-size: 0.95rem;
    }
    
    .toast-success {
      border-color: rgba(64, 192, 87, 0.5);
      background: rgba(64, 192, 87, 0.1);
    }
    
    .toast-warning {
      border-color: rgba(250, 176, 5, 0.5);
      background: rgba(250, 176, 5, 0.1);
    }
    
    .toast-error {
      border-color: rgba(250, 82, 82, 0.5);
      background: rgba(250, 82, 82, 0.1);
    }
    
    .toast-info {
      border-color: rgba(77, 171, 247, 0.5);
      background: rgba(77, 171, 247, 0.1);
    }
    
    /* Download Error Modal */
    .download-error-modal {
      max-width: 450px;
      background: var(--bg-secondary);
      border-radius: 12px;
      overflow: hidden;
    }
    
    .download-error-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
    }
    
    .download-error-header.warning {
      background: rgba(250, 176, 5, 0.15);
      border-bottom-color: rgba(250, 176, 5, 0.3);
    }
    
    .download-error-header.error {
      background: rgba(250, 82, 82, 0.15);
      border-bottom-color: rgba(250, 82, 82, 0.3);
    }
    
    .download-error-header h3 {
      margin: 0;
      font-size: 1.1rem;
      color: var(--text);
    }
    
    .download-error-body {
      padding: 20px;
    }
    
    .download-error-body p {
      margin: 0 0 12px 0;
      color: var(--text);
      line-height: 1.5;
    }
    
    .download-error-details {
      font-family: monospace;
      font-size: 0.85rem;
      color: var(--text-secondary);
      background: var(--bg-primary);
      padding: 8px 12px;
      border-radius: 6px;
      word-break: break-all;
    }
    
    .download-error-suggestion {
      color: var(--text-secondary);
      font-size: 0.9rem;
      margin-top: 16px !important;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    
    .download-error-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      padding: 16px 20px;
      border-top: 1px solid var(--border);
      background: var(--bg-primary);
    }
    
    /* Trash Modal */
    .trash-modal {
      max-width: 700px;
      max-height: 80vh;
    }
    
    .trash-summary {
      padding: 12px 16px;
      background: var(--bg-primary);
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }
    
    .trash-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .trash-tab {
      flex: 1;
      padding: 10px 16px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .trash-tab:hover {
      background: var(--bg-secondary);
    }
    
    .trash-tab.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }
    
    .trash-tab-count {
      background: rgba(255,255,255,0.2);
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 0.8rem;
    }
    
    .trash-tab.active .trash-tab-count {
      background: rgba(255,255,255,0.3);
    }
    
    .trash-list {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
    }
    
    .trash-empty {
      padding: 40px;
      text-align: center;
      color: var(--text-secondary);
    }
    
    .trash-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      transition: background 0.15s;
    }
    
    .trash-item:last-child {
      border-bottom: none;
    }
    
    .trash-item:hover {
      background: var(--bg-primary);
    }
    
    .trash-item-icon {
      font-size: 1.5rem;
      opacity: 0.6;
    }
    
    .trash-item-info {
      flex: 1;
      min-width: 0;
    }
    
    .trash-item-name {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .trash-item-meta {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-top: 2px;
    }
    
    .trash-item-actions {
      display: flex;
      gap: 8px;
    }
    
    .trash-item-actions button {
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-primary);
      color: var(--text);
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.15s;
    }
    
    .trash-item-actions button:hover {
      background: var(--bg-secondary);
    }
    
    .trash-item-actions .restore-btn:hover {
      background: rgba(64, 192, 87, 0.2);
      border-color: rgba(64, 192, 87, 0.5);
    }
    
    .trash-item-actions .delete-btn:hover {
      background: rgba(250, 82, 82, 0.2);
      border-color: rgba(250, 82, 82, 0.5);
    }
    
    .trash-footer {
      justify-content: space-between;
    }
    
    .btn-danger {
      background: #e74c3c;
      color: white;
      border: none;
    }
    
    .btn-danger:hover:not(:disabled) {
      background: #c0392b;
    }
    
    .btn-danger:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .settings-footer {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      padding: 16px 20px;
      border-top: 1px solid var(--border);
    }
    
    /* Directory Browser */
    .browser-modal {
      background: var(--bg-secondary);
      border-radius: 12px;
      width: 90%;
      max-width: 450px;
      max-height: 70vh;
      display: flex;
      flex-direction: column;
    }
    
    .browser-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
    }
    
    .browser-header h3 {
      margin: 0;
      font-size: 1.1rem;
    }
    
    .browser-path {
      padding: 10px 20px;
      background: var(--bg-card);
      font-family: monospace;
      font-size: 0.85rem;
      color: var(--accent);
      border-bottom: 1px solid var(--border);
    }
    
    .browser-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }
    
    .browser-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-primary);
    }
    
    .browser-item:hover {
      background: var(--bg-card);
    }
    
    .browser-item.parent {
      color: var(--text-secondary);
    }
    
    .browser-footer {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      padding: 12px 20px;
      border-top: 1px solid var(--border);
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .app {
        grid-template-columns: 1fr;
      }
      .sidebar {
        display: none;
      }
      .modal-body {
        grid-template-columns: 1fr;
      }
    }
    
    /* Page Preview Modal */
    .page-preview-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    
    .page-preview-overlay.active {
      display: flex;
    }
    
    .page-preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      max-width: 900px;
      padding: 12px 20px;
      color: white;
    }
    
    .page-preview-nav {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    
    .page-preview-nav button, .page-preview-zoom button {
      background: rgba(255,255,255,0.1);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.2rem;
      transition: background 0.2s;
    }
    
    .page-preview-nav button:hover:not(:disabled),
    .page-preview-zoom button:hover:not(:disabled) {
      background: var(--accent);
    }
    
    .page-preview-nav button:disabled,
    .page-preview-zoom button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    .page-preview-info {
      font-size: 0.95rem;
      color: rgba(255,255,255,0.8);
    }
    
    .page-preview-zoom {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 24px;
      padding-left: 24px;
      border-left: 1px solid rgba(255,255,255,0.2);
    }
    
    .page-preview-zoom button {
      width: 36px;
      height: 36px;
      font-size: 1.1rem;
    }
    
    .zoom-level {
      font-size: 0.85rem;
      color: rgba(255,255,255,0.7);
      min-width: 50px;
      text-align: center;
    }
    
    .page-preview-title {
      font-size: 0.85rem;
      color: rgba(255,255,255,0.6);
      max-width: 400px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .page-preview-close {
      background: none;
      border: none;
      color: white;
      font-size: 2rem;
      cursor: pointer;
      padding: 8px;
      line-height: 1;
    }
    
    .page-preview-close:hover {
      color: var(--accent);
    }
    
    .page-preview-image-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow: auto;
      max-width: 100%;
    }
    
    .page-preview-image {
      max-height: calc(100vh - 200px);
      max-width: 100%;
      object-fit: contain;
      border-radius: 4px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    
    .page-preview-image.loading {
      opacity: 0.5;
    }
    
    .page-preview-footer {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 16px 20px;
      background: rgba(0,0,0,0.5);
      width: 100%;
    }
    
    .page-preview-footer label {
      color: rgba(255,255,255,0.7);
      font-size: 0.9rem;
    }
    
    .page-range-select {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(30,30,50,0.95);
      color: white;
      font-size: 0.9rem;
      cursor: pointer;
    }
    
    .page-range-select option {
      background: #1e1e32;
      color: white;
      padding: 8px;
    }
    
    .page-range-select:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .page-preview-download {
      padding: 10px 24px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .page-preview-download:hover {
      background: var(--accent-hover);
    }
  </style>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"></head>
<body>
  <div class="app">
    <header>
      <div class="logo" onclick="goHome()" style="cursor:pointer" title="Return to home view"> FantasyFolio</div>
      <div class="search-box">
        <input type="text" id="searchInput" placeholder="Search PDFs..." />
        <button class="adv-search-toggle" onclick="toggleAdvancedSearch()" title="Advanced Search"></button>
      </div>
      <div class="content-toggle">
        <button class="toggle-btn active" id="togglePdf" onclick="setContentType('pdf')"> PDFs</button>
        <button class="toggle-btn" id="toggle3d" onclick="setContentType('3d')"> 3D Models</button>
      </div>
      <div class="stats" id="stats">Loading...</div>
      <button class="settings-btn" onclick="openUpload()" title="Upload files" id="uploadBtn"></button>
      <button class="settings-btn" onclick="openSettings()" title="Settings"><span class="trash-badge" id="trashBadge" style="display:none">0</span></button>
    </header>
    
    <div class="advanced-search-panel" id="advancedSearchPanel">
      <button class="adv-search-close" onclick="toggleAdvancedSearch()" title="Close"></button>
      <div class="adv-search-row">
        <div class="adv-search-group">
          <label>Search in:</label>
          <select id="advSearchScope">
            <option value="all">All folders</option>
            <option value="current" id="advScopeCurrent">Current folder</option>
          </select>
        </div>
        <div class="adv-search-group" id="advFormatGroup">
          <label>File type:</label>
          <select id="advSearchFormat">
            <option value="">Any format</option>
            <option value="stl">STL</option>
            <option value="obj">OBJ</option>
            <option value="3mf">3MF</option>
            <option value="pdf">PDF</option>
          </select>
        </div>
      </div>
      
      <div class="adv-search-terms" id="advSearchTerms">
        <div class="adv-term-row" data-row="0">
          <span class="term-label">Find in</span>
          <select class="term-field">
            <option value="all">Title & Content</option>
            <option value="title">Title only</option>
            <option value="content">Content only</option>
          </select>
          <select class="term-include">
            <option value="include">contains</option>
            <option value="exclude">does NOT contain</option>
          </select>
          <input type="text" class="term-input" placeholder="Enter search term..." />
        </div>
      </div>
      
      <div class="adv-search-row" style="margin-top:12px">
        <button class="btn-add-term" onclick="addSearchTerm()">+ Add condition</button>
        <div style="margin-left:auto; display:flex; gap:8px;">
          <button class="btn-apply" onclick="runAdvancedSearch()">Search</button>
          <button class="btn-clear" onclick="clearAdvancedSearch()">Clear</button>
        </div>
      </div>
    </div>
    
    <div class="app-body">
    <aside class="sidebar" id="sidebar">
      <!-- PDF Navigation -->
      <div id="pdfNav">
        <h3> Folders</h3>
        <div class="folder-tree" id="folderTree"></div>
        
        <h3> Publishers</h3>
        <ul class="publisher-list" id="publisherList"></ul>
      </div>
      
      <!-- 3D Models Navigation -->
      <div id="modelsNav" style="display:none;">
        <h3> Folders</h3>
        <div class="folder-tree" id="modelFolderTree"></div>
        
        <h3> Collections</h3>
        <ul class="collection-list" id="collectionList"></ul>
      </div>
    </aside>
    <div class="resize-handle" id="resizeHandle"></div>
    
    <main class="main">
      <div class="view-controls">
        <button class="view-btn active" data-view="grid">Grid</button>
        <button class="view-btn" data-view="list">List</button>
        <div class="sort-controls">
          <select id="formatFilter" onchange="changeFormatFilter()" style="display:none;">
            <option value="">All Formats</option>
            <option value="stl">STL</option>
            <option value="obj">OBJ</option>
            <option value="3mf">3MF</option>
            <option value="glb">GLB</option>
            <option value="gltf">glTF</option>
          </select>
          <select id="sortSelect">
            <option value="filename:asc">Name (A-Z)</option>
            <option value="filename:desc">Name (Z-A)</option>
            <option value="title:asc">Title (A-Z)</option>
            <option value="title:desc">Title (Z-A)</option>
            <option value="file_size:desc">Size (Large first)</option>
            <option value="file_size:asc">Size (Small first)</option>
            <option value="page_count:desc">Pages (Most first)</option>
            <option value="page_count:asc">Pages (Least first)</option>
            <option value="modified_at:desc">Modified (Newest)</option>
            <option value="modified_at:asc">Modified (Oldest)</option>
          </select>
          <button class="clear-btn" onclick="clearFilters()" title="Clear all filters"> Clear</button>
        </div>
      </div>
      
      <div class="main-scroll">
        <div class="content-results" id="contentResults" style="display:none;"></div>
        <div class="asset-grid" id="assetGrid"></div>
        <div class="asset-list" id="assetList"></div>
      </div>
    </main>
  </div>
  </div>
  
  <!-- Detail Modal -->
  <div class="modal-overlay" id="modal">
    <div class="modal">
      <div class="modal-header">
        <h3>Asset Details</h3>
        <button class="modal-close" onclick="closeModal()">&times;</button>
      </div>
      <div class="modal-body" id="modalBody"></div>
    </div>
  </div>

  <!-- Page Preview Modal -->
  <div class="page-preview-overlay" id="pagePreview">
    <div class="page-preview-header">
      <div class="page-preview-nav">
        <button onclick="previewPrevPage()" id="prevPageBtn" title="Previous page"></button>
        <span class="page-preview-info">
          Page <span id="previewPageNum">1</span> of <span id="previewTotalPages">1</span>
        </span>
        <button onclick="previewNextPage()" id="nextPageBtn" title="Next page"></button>
        <div class="page-preview-zoom">
          <button onclick="zoomOut()" title="Zoom out"></button>
          <span class="zoom-level" id="zoomLevel">100%</span>
          <button onclick="zoomIn()" title="Zoom in">+</button>
          <button onclick="zoomReset()" title="Reset zoom" style="font-size:0.8rem"></button>
        </div>
      </div>
      <div class="page-preview-title" id="previewTitle"></div>
      <button class="page-preview-close" onclick="closePagePreview()" title="Close">&times;</button>
    </div>
    <div class="page-preview-image-container">
      <img class="page-preview-image" id="previewImage" src="" alt="Page preview" />
    </div>
    <div class="page-preview-footer">
      <label>Download:</label>
      <select class="page-range-select" id="pageRangeSelect">
        <option value="0">This page only</option>
        <option value="1"> 1 page (3 pages)</option>
        <option value="2"> 2 pages (5 pages)</option>
        <option value="5"> 5 pages (11 pages)</option>
        <option value="custom">Custom range...</option>
      </select>
      <button class="page-preview-download" onclick="downloadPreviewPages()">
         Download PDF
      </button>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="settings-overlay" id="settingsModal">
    <div class="settings-modal settings-modal-large">
      <div class="settings-header">
        <h2> Settings</h2>
        <button class="settings-close" onclick="closeSettings()"></button>
      </div>
      
      <!-- Settings Tabs -->
      <div class="settings-tabs">
        <button class="settings-tab active" onclick="switchSettingsTab('general')" id="settingsTabGeneral">
           General
        </button>
        <button class="settings-tab" onclick="switchSettingsTab('advanced')" id="settingsTabAdvanced">
           Advanced
        </button>
      </div>
      
      <!-- General Tab -->
      <div class="settings-body settings-tab-content" id="settingsGeneral">
        <div class="settings-section">
          <h3> Asset Locations</h3>
          <p class="settings-hint">Configure where your documents and 3D models are stored.</p>
          
          <!-- Asset Locations List -->
          <div class="asset-locations-list" id="assetLocationsList">
            <div class="location-empty">Loading...</div>
          </div>
          
          <!-- Add Location Button -->
          <button class="btn btn-primary" onclick="showAddLocationModal()" style="margin-top: 12px;">
             Add Asset Location
          </button>
        </div>
        
        <div class="settings-section">
          <h3> Reindex Library</h3>
          <p style="font-size: 0.9rem; color: #888; margin-bottom: 12px;">Scan your configured locations to find new or changed files. Run after adding files or enabling new locations.</p>
          <div class="index-buttons-row" style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="index-btn" onclick="indexNow('pdf')" title="Scan all document locations for new/changed PDFs"> Scan Documents</button>
            <button class="index-btn" onclick="indexNow('3d')" title="Scan all 3D model locations for new/changed files"> Scan 3D Models</button>
            <button class="index-btn" onclick="openIndexDirectoryPicker()" title="Browse and index a specific directory"> Index Directory...</button>
          </div>
          <div class="index-status" id="pdfIndexStatus"></div>
          <div class="index-status" id="3dIndexStatus"></div>
        </div>
        
        <div class="settings-section">
          <h3> 3D Model Maintenance</h3>
          <div class="settings-field">
            <label>Thumbnail Generation</label>
            <p style="font-size: 0.9rem; color: #888; margin-bottom: 12px;">Render missing or low-quality thumbnails for faster browsing</p>
            <div class="path-input-row">
              <button type="button" class="index-btn" onclick="renderAllThumbnails()" title="Render thumbnails for all 3D models" id="renderThumbBtn"> Render Thumbnails</button>
              <button type="button" class="index-btn" onclick="renderThumbStats(this)" title="Check thumbnail status"> Check Status</button>
            </div>
            <div class="index-status" id="renderThumbStatus"></div>
          </div>
        </div>
        
      </div>
      
      <!-- Advanced Tab -->
      <div class="settings-body settings-tab-content" id="settingsAdvanced" style="display:none;">
        
        <!-- Trash Section -->
        <div class="settings-section">
          <h3> Trash</h3>
          <div class="trash-summary" id="trashSummary">
            <span class="trash-count">Loading...</span>
          </div>
          
          <div class="trash-tabs">
            <button class="trash-tab active" onclick="switchTrashTab('assets')" id="trashTabAssets">
               PDFs <span class="trash-tab-count" id="trashAssetCount">0</span>
            </button>
            <button class="trash-tab" onclick="switchTrashTab('models')" id="trashTabModels">
               Models <span class="trash-tab-count" id="trashModelCount">0</span>
            </button>
          </div>
          
          <div class="trash-list" id="trashList">
            <div class="trash-empty">Trash is empty</div>
          </div>
          
          <div class="trash-actions">
            <button class="btn btn-danger" onclick="emptyTrash()" id="emptyTrashBtn" disabled> Empty Trash</button>
          </div>
        </div>
        
        <!-- Change Journal Section -->
        <div class="settings-section">
          <h3> Change Journal</h3>
          <p class="settings-hint">Track all modifications to your assets for audit and recovery.</p>
          <div class="journal-controls" id="journalControls">
            <div class="journal-status" id="journalStatus">
              <span class="status-indicator journal-active"></span> 
              <span id="journalStatusText">Loading...</span>
            </div>
            <button class="index-btn" onclick="toggleJournalView()" id="viewJournalBtn"> View Activity</button>
            <select id="journalFilter" onchange="loadJournalEntries()" style="margin-left: 8px;">
              <option value="">All actions</option>
              <option value="create">Creates</option>
              <option value="trash">Deletes</option>
              <option value="restore">Restores</option>
              <option value="update">Updates</option>
            </select>
          </div>
          <div class="journal-list" id="journalList"></div>
        </div>
        
        <!-- Snapshots Section -->
        <div class="settings-section">
          <h3> Database Snapshots</h3>
          <p class="settings-hint">Point-in-time backups for disaster recovery.</p>
          
          <div class="snapshot-controls">
            <button class="index-btn" onclick="createSnapshot()"> Create Snapshot</button>
            <button class="index-btn" onclick="toggleSnapshotList()" id="toggleSnapshotsBtn"> View All</button>
          </div>
          <div class="snapshot-status" id="snapshotStatus">
            Last snapshot: <span id="lastSnapshotTime">Never</span>
          </div>
          <div class="snapshot-list" id="snapshotList"></div>
        </div>
        
        <!-- Restic Snapshots Modal (shown when viewing policy snapshots) -->
        <div class="restic-snapshots-panel" id="resticSnapshotsPanel" style="display:none;">
          <div class="restic-panel-header">
            <h4> Snapshots: <span id="resticPolicyName">-</span></h4>
            <button class="btn btn-secondary btn-sm" onclick="closeResticSnapshots()"> Close</button>
          </div>
          <div class="restic-status" id="resticSnapshotsStatus"></div>
          <div class="snapshot-list" id="resticSnapshotList"></div>
        </div>
        
        <!-- Backup Policies Section -->
        <div class="settings-section">
          <h3> Backup</h3>
          
          <!-- Active Policies -->
          <div class="policy-section">
            <h4>Active Policies</h4>
            <div class="policy-table" id="activePoliciesTable">
              <div class="policy-table-header">
                <span class="col-name">Name</span>
                <span class="col-dest">Destination</span>
                <span class="col-freq">Frequency</span>
                <span class="col-last">Last Backup</span>
                <span class="col-next">Next Scheduled</span>
                <span class="col-state">State</span>
                <span class="col-actions">Actions</span>
              </div>
              <div class="policy-table-body" id="activePoliciesList">
                <div class="policy-empty">No active policies</div>
              </div>
            </div>
          </div>
          
          <!-- Inactive/Disabled Policies -->
          <div class="policy-section">
            <h4>Inactive/Disabled Policies</h4>
            <div class="policy-table" id="inactivePoliciesTable">
              <div class="policy-table-body" id="inactivePoliciesList">
                <div class="policy-empty">No inactive policies</div>
              </div>
            </div>
          </div>
          
          <!-- Add Policy Form -->
          <div class="policy-add-section">
            <h4> Add Policy</h4>
            <div class="policy-add-form" id="policyAddForm">
              <div class="policy-add-row">
                <input type="text" id="newPolicyName" placeholder="Policy Name" class="policy-input name" />
                <select id="newPolicyDestType" onchange="toggleDestinationFields()" class="policy-input dest-type">
                  <option value="local">Local (copy)</option>
                  <option value="restic">Restic Local (dedup)</option>
                  <option value="restic-remote">Restic Remote (dedup)</option>
                  <option value="network">Network (SSH/rsync)</option>
                </select>
                <div class="path-input-wrapper" id="localPathWrapper">
                  <input type="text" id="newPolicyPath" placeholder="/path/to/backups" class="policy-input path" />
                  <button type="button" class="browse-btn" onclick="browseBackupPath()"> Browse</button>
                </div>
                <input type="text" id="newPolicySshHost" placeholder="user@host" class="policy-input ssh-host" style="display:none;" />
                <input type="password" id="newPolicyResticPassword" placeholder="Repo password" class="policy-input restic-pw" style="display:none;" />
                <input type="password" id="newPolicyResticPasswordConfirm" placeholder="Confirm password" class="policy-input restic-pw" style="display:none;" />
              </div>
              <div class="policy-add-row">
                <span class="field-label">Schedule:</span>
                <select id="newPolicyFrequency" class="policy-input frequency">
                  <option value="daily" selected>Daily</option>
                  <option value="weekly">Weekly</option>
                  <option value="monthly">Monthly</option>
                  <option value="yearly">Yearly</option>
                </select>
                <span class="field-label">at</span>
                <input type="time" id="newPolicyTime" class="policy-input time" value="02:00" />
                <span class="field-label">starting</span>
                <input type="date" id="newPolicyStartDate" class="policy-input date" />
              </div>
              <div class="policy-add-row">
                <span class="field-label">Keep</span>
                <input type="number" id="newPolicyRetention" class="policy-input retention" value="7" min="1" max="365" />
                <span class="field-label">copies</span>
                <select id="newPolicyState" class="policy-input state">
                  <option value="disabled">Disabled</option>
                  <option value="paused">Paused</option>
                  <option value="active">Active</option>
                </select>
                <button class="btn btn-primary policy-save-btn" onclick="saveNewPolicy()"> Save</button>
              </div>
              <div class="policy-add-row network-fields" id="networkFields" style="display:none;">
                <span class="field-label">SSH Key:</span>
                <input type="text" id="newPolicySshKey" placeholder="~/.ssh/id_rsa (optional)" class="policy-input ssh-key" />
                <button class="btn btn-secondary" onclick="showSshKeyHelp()"> Help</button>
                <button class="btn btn-secondary" onclick="testPolicyConnection()"> Test Connection</button>
              </div>
              <div class="policy-validation-msg" id="policyValidationMsg"></div>
            </div>
          </div>
        </div>
        
      </div>
      
      <div class="settings-footer">
        <button class="btn btn-secondary" onclick="closeSettings()">Cancel</button>
        <button class="btn btn-primary" onclick="saveSettings()"> Save Settings</button>
      </div>
    </div>
  </div>

  <!-- Directory Browser Modal -->
  <div class="dir-browser-overlay" id="dirBrowserModal">
    <div class="dir-browser-modal">
      <div class="dir-browser-header">
        <h3> Select Directory</h3>
        <button class="upload-close" onclick="closeDirBrowser()"></button>
      </div>
      <div class="dir-browser-path" id="dirBrowserPath">/</div>
      <div class="dir-browser-list" id="dirBrowserList">
        <div class="dir-browser-empty">Loading...</div>
      </div>
      <div class="dir-browser-newfolder">
        <input type="text" id="newFolderInput" placeholder="New folder name..." />
        <button class="btn btn-secondary" onclick="createNewFolder()"> Create</button>
      </div>
      <div class="dir-browser-footer">
        <button class="btn btn-secondary" onclick="closeDirBrowser()">Cancel</button>
        <button class="btn btn-primary" onclick="selectCurrentDir()"> Select This Directory</button>
      </div>
    </div>
  </div>

  <!-- SSH Key Help Modal -->
  <div class="dir-browser-overlay" id="sshKeyHelpModal">
    <div class="dir-browser-modal" style="max-width: 550px;">
      <div class="dir-browser-header">
        <h3> SSH Key Setup</h3>
        <button class="upload-close" onclick="closeSshKeyHelp()"></button>
      </div>
      <div style="padding: 20px; line-height: 1.6;">
        <p style="margin-bottom: 16px;">SSH keys allow secure, password-free connections to remote servers.</p>
        
        <div id="sshKeyLoading" style="text-align: center; padding: 20px;">
          Loading available keys...
        </div>
        
        <div id="sshKeyOptions" style="display: none;">
          <!-- Select Existing Key -->
          <div class="form-row" style="margin-bottom: 16px;">
            <label style="font-weight: 500; margin-bottom: 6px; display: block;">Use Existing Key</label>
            <select id="sshKeySelect" onchange="onSshKeySelected()" style="width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text); font-size: 0.95rem;">
              <option value="">-- Select a key --</option>
            </select>
          </div>
          
          <!-- Or Create New -->
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
            <span style="color: var(--text-secondary);"> or </span>
            <button class="btn btn-primary" onclick="generateSshKey()" id="generateKeyBtn"> Create New Key</button>
          </div>
          
          <!-- Selected Key Info (shown when key selected) -->
          <div id="sshKeyInfo" style="display: none; background: var(--bg-primary); border-radius: 8px; padding: 16px; border: 1px solid var(--border);">
            <h4 style="margin: 0 0 12px 0; color: #40c057;"> Key Selected</h4>
            <p style="font-size: 0.9rem; margin-bottom: 12px;">Path: <code id="sshKeyPathDisplay"></code></p>
            
            <label style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 6px; display: block;">Public key (copy to remote server's ~/.ssh/authorized_keys):</label>
            <div style="position: relative;">
              <pre id="sshPublicKeyDisplay" style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px; margin: 0; overflow-x: auto; font-size: 0.8rem; white-space: pre-wrap; word-break: break-all; max-height: 80px;"></pre>
              <button onclick="copySshPublicKey()" style="position: absolute; top: 8px; right: 8px; padding: 4px 8px; font-size: 0.75rem; background: var(--accent); border: none; border-radius: 4px; color: white; cursor: pointer;"> Copy</button>
            </div>
          </div>
          
          <!-- Test Connection -->
          <div id="sshTestSection" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
            <label style="font-weight: 500; margin-bottom: 6px; display: block;">Test Connection</label>
            <div style="display: flex; gap: 8px;">
              <input type="text" id="sshTestHost" placeholder="user@hostname" style="flex: 1; padding: 10px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text);" />
              <button class="btn btn-test-connection" onclick="testSshConnectionFromModal()" id="sshTestBtn"> Test</button>
            </div>
            <div id="sshTestResult" style="margin-top: 8px; font-size: 0.9rem;"></div>
          </div>
        </div>
        
        <p style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border);">
           <a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh" target="_blank" style="color: var(--accent);">SSH Key Guide</a>
        </p>
      </div>
      <div class="dir-browser-footer">
        <button class="btn btn-secondary" onclick="closeSshKeyHelp()">Cancel</button>
        <button class="btn btn-primary" onclick="useSshKey()" id="useSshKeyBtn" style="display: none;">Use This Key</button>
      </div>
    </div>
  </div>

  <!-- Delete Location Confirmation -->
  <div class="delete-confirm-overlay" id="deleteConfirmOverlay">
    <div class="delete-confirm-modal">
      <h3> Delete Location?</h3>
      <p>Are you sure you want to delete "<span id="deleteLocName"></span>"?<br><br>This will remove the location from FantasyFolio but won't delete any files.</p>
      <div class="buttons">
        <button class="btn btn-secondary" onclick="cancelDelete()">Cancel</button>
        <button class="btn btn-primary" style="background: #fa5252;" onclick="executeDelete()">Yes, Delete</button>
      </div>
    </div>
  </div>

  <!-- Add Asset Location Modal -->
  <div class="dir-browser-overlay" id="addLocationModal">
    <div class="dir-browser-modal" style="max-width: 600px; width: 95%;">
      <div class="dir-browser-header">
        <h3> Add Asset Location</h3>
        <button class="upload-close" onclick="closeAddLocationModal()"></button>
      </div>
      <div class="add-location-form">
        <div class="form-row">
          <label>Name</label>
          <input type="text" id="locName" placeholder="e.g., Main Document Archive" />
        </div>
        
        <div class="form-row">
          <label>Asset Type</label>
          <select id="locAssetType">
            <option value="documents"> Documents (PDFs)</option>
            <option value="models"> 3D Models</option>
          </select>
        </div>
        
        <div class="form-row">
          <label>Location Type</label>
          <select id="locType" onchange="toggleLocationFields()">
            <option value="local">Local Path</option>
            <option value="local_mount">Network Mount (SMB/NFS/AFP)</option>
            <option value="remote_sftp" id="optionSftp">Remote SFTP (Linux only)</option>
          </select>
          <p class="field-hint" id="sftpDisabledHint" style="display: none; color: #ff6b6b;">SFTP indexing requires sshfs, which needs kernel extensions on macOS/Windows. Only available on Linux.</p>
        </div>
        
        <div class="form-row">
          <label>Path</label>
          <div class="input-with-btn">
            <input type="text" id="locPath" placeholder="/path/to/assets" />
            <button class="btn btn-secondary" onclick="browseLocationPath()" id="locBrowseBtn"></button>
          </div>
        </div>
        
        <div class="form-row" id="locSshHostRow" style="display: none;">
          <label>SSH Host</label>
          <input type="text" id="locSshHost" placeholder="user@hostname or SSH config alias" />
        </div>
        
        <div class="form-row" id="locSshKeyRow" style="display: none;">
          <label>SSH Authentication</label>
          
          <!-- Option selector -->
          <div class="ssh-auth-options">
            <label class="ssh-auth-option">
              <input type="radio" name="sshAuthMethod" value="existing" onchange="onSshAuthMethodChange()">
              <span> Use Existing Key</span>
            </label>
            <label class="ssh-auth-option">
              <input type="radio" name="sshAuthMethod" value="create" onchange="onSshAuthMethodChange()">
              <span> Create New Key</span>
            </label>
            <label class="ssh-auth-option advanced">
              <input type="radio" name="sshAuthMethod" value="config" onchange="onSshAuthMethodChange()">
              <span> Advanced: SSH Config</span>
            </label>
          </div>
          
          <!-- Use Existing Key Panel -->
          <div id="sshExistingPanel" class="ssh-auth-panel" style="display: none;">
            <select id="locSshKeySelect" onchange="onLocKeySelected()" style="width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text); margin-bottom: 8px;">
              <option value="">-- Select a key --</option>
            </select>
            <div id="locKeyInfo" style="display: none; background: var(--bg-card); padding: 12px; border-radius: 6px; margin-top: 8px;">
              <p style="font-size: 0.85rem; margin-bottom: 8px;"> Copy this public key to your remote server's <code>~/.ssh/authorized_keys</code>:</p>
              <pre id="locPublicKeyDisplay" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; font-size: 0.75rem; overflow-x: auto; white-space: pre-wrap; word-break: break-all; max-height: 60px;"></pre>
              <div style="display: flex; gap: 8px; margin-top: 8px;">
                <button type="button" class="btn btn-secondary btn-sm" onclick="copyLocPublicKey()"> Copy Key</button>
                <a href="https://www.ssh.com/academy/ssh/authorized-keys-file" target="_blank" style="font-size: 0.8rem; color: var(--accent); align-self: center;"> How to add to authorized_keys</a>
              </div>
            </div>
          </div>
          
          <!-- Create New Key Panel -->
          <div id="sshCreatePanel" class="ssh-auth-panel" style="display: none;">
            <div id="locCreateKeyStatus">
              <button type="button" class="btn btn-primary" onclick="createNewKeyForLocation()"> Generate New SSH Key</button>
              <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 8px;">This will create a new key pair in <code>~/.ssh/</code></p>
            </div>
            <div id="locNewKeyInfo" style="display: none; background: var(--bg-card); padding: 12px; border-radius: 6px; margin-top: 8px;">
              <p style="font-size: 0.85rem; color: #40c057; margin-bottom: 8px;"> Key created! Copy this public key to your remote server:</p>
              <pre id="locNewPublicKeyDisplay" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; font-size: 0.75rem; overflow-x: auto; white-space: pre-wrap; word-break: break-all; max-height: 60px;"></pre>
              <div style="display: flex; gap: 8px; margin-top: 8px;">
                <button type="button" class="btn btn-secondary btn-sm" onclick="copyLocNewPublicKey()"> Copy Key</button>
                <a href="https://www.ssh.com/academy/ssh/authorized-keys-file" target="_blank" style="font-size: 0.8rem; color: var(--accent); align-self: center;"> How to add to authorized_keys</a>
              </div>
            </div>
          </div>
          
          <!-- SSH Config Panel -->
          <div id="sshConfigPanel" class="ssh-auth-panel" style="display: none;">
            <div style="background: var(--bg-card); padding: 12px; border-radius: 6px;">
              <p style="font-size: 0.9rem; margin-bottom: 8px;">SSH Config lets you define connection settings in <code>~/.ssh/config</code>.</p>
              <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px;">Your SSH Host above can be a config alias (e.g., "myserver" instead of "user@192.168.1.100").</p>
              <a href="https://www.ssh.com/academy/ssh/config" target="_blank" class="btn btn-secondary btn-sm"> SSH Config Guide</a>
            </div>
          </div>
        </div>
        
        <div class="form-row" id="locTestConnectionRow" style="display: none;">
          <button type="button" class="btn btn-test-connection" onclick="testLocationConnection()" id="locTestConnBtn">
             Test Connection
          </button>
          <span class="test-result" id="locTestResult"></span>
        </div>
        
        <div class="form-row">
          <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="locEnabled" checked style="width: auto;" />
            Enabled
          </label>
        </div>
      </div>
      <div class="dir-browser-footer">
        <div id="locValidationMsg" style="flex: 1; font-size: 0.85rem;"></div>
        <button class="btn btn-secondary" onclick="closeAddLocationModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveNewLocation()"> Save</button>
      </div>
    </div>
  </div>

  <!-- Upload Modal -->
  <div class="upload-overlay" id="uploadModal">
    <div class="upload-modal">
      <div class="upload-header">
        <h2><span id="uploadIcon"></span> Upload <span id="uploadTypeLabel">PDFs</span></h2>
        <button class="upload-close" onclick="closeUpload()"></button>
      </div>
      <div class="upload-body">
        <div class="upload-section">
          <h3> Select Destination Folder</h3>
          <div class="upload-path-display">
            <span class="path" id="uploadCurrentPath">Loading...</span>
          </div>
          <div class="upload-folder-list" id="uploadFolderList"></div>
          <div class="upload-new-folder">
            <input type="text" id="newFolderName" placeholder="New folder name..." />
            <button onclick="createUploadFolder()"> Create</button>
          </div>
        </div>
        
        <div class="upload-section">
          <h3> Select Files</h3>
          <div class="upload-dropzone" id="uploadDropzone" onclick="document.getElementById('uploadFileInput').click()">
            <div class="upload-dropzone-icon"></div>
            <div class="upload-dropzone-text">Drop files here or click to browse</div>
            <div class="upload-dropzone-hint" id="uploadHint">Accepted: .pdf</div>
          </div>
          <input type="file" id="uploadFileInput" multiple style="display:none" onchange="handleFileSelect(event)" />
          <div class="upload-file-list" id="uploadFileList"></div>
          <div class="upload-progress" id="uploadProgress">
            <div class="upload-progress-bar">
              <div class="upload-progress-fill" id="uploadProgressFill"></div>
            </div>
            <div class="upload-progress-text" id="uploadProgressText">Uploading...</div>
          </div>
        </div>
      </div>
      <div class="upload-footer">
        <div class="file-count" id="uploadFileCount">No files selected</div>
        <div class="buttons">
          <button class="btn btn-secondary" onclick="closeUpload()">Cancel</button>
          <button class="btn btn-primary" id="uploadSubmitBtn" onclick="submitUpload()" disabled> Upload</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Directory Browser Modal -->
  <div class="browser-overlay" id="browserModal">
    <div class="browser-modal">
      <div class="browser-header">
        <h3> Select Directory</h3>
        <button class="browser-close" onclick="closeBrowser()"></button>
      </div>
      <div class="browser-path" id="browserPath">/Volumes</div>
      <div class="browser-list" id="browserList"></div>
      <div class="browser-footer">
        <button class="btn btn-secondary" onclick="closeBrowser()">Cancel</button>
        <button class="btn btn-primary" onclick="selectBrowserPath()"> Select</button>
      </div>
    </div>
  </div>

  <!-- Column Browser for Index Directory -->
  <div class="browser-overlay" id="columnBrowserModal">
    <div class="column-browser-modal">
      <div class="browser-header">
        <h3> Select Directory to Index</h3>
        <button class="browser-close" onclick="closeColumnBrowser()"></button>
      </div>
      <div class="column-browser-path" id="columnBrowserPath">Select an asset volume</div>
      <div class="column-browser-container" id="columnBrowserContainer">
        <div class="column-browser-columns" id="columnBrowserColumns">
          <!-- Columns will be added here dynamically -->
        </div>
      </div>
      <div class="browser-footer" style="flex-wrap: wrap; gap: 12px;">
        <div style="display: flex; gap: 16px; margin-right: auto;">
          <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
            <input type="checkbox" id="forceIndexCheckbox"> Force re-index
          </label>
          <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
            <input type="checkbox" id="regenThumbnailsCheckbox"> Regenerate thumbnails
          </label>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn btn-secondary" onclick="closeColumnBrowser()">Cancel</button>
          <button class="btn btn-primary" onclick="confirmColumnBrowserSelection()" id="columnBrowserSelectBtn" disabled> Index Selected</button>
        </div>
      </div>
    </div>
  </div>

  <style>
    .column-browser-modal {
      background: var(--bg-secondary);
      border-radius: 12px;
      width: 90%;
      max-width: 900px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    .column-browser-path {
      padding: 8px 16px;
      background: rgba(0,0,0,0.2);
      font-family: monospace;
      font-size: 0.85rem;
      color: var(--accent);
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .column-browser-container {
      flex: 1;
      overflow: hidden;
      min-height: 300px;
    }
    .column-browser-columns {
      display: flex;
      height: 100%;
      overflow-x: auto;
      overflow-y: hidden;
    }
    .column-browser-column {
      min-width: 200px;
      max-width: 250px;
      border-right: 1px solid var(--border);
      overflow-y: auto;
      flex-shrink: 0;
    }
    .column-browser-column:last-child {
      border-right: none;
    }
    .column-item {
      padding: 10px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .column-item:hover {
      background: rgba(255,255,255,0.1);
    }
    .column-item.selected {
      background: var(--accent);
      color: white;
    }
    .column-item.volume {
      font-weight: 600;
    }
    .column-item .icon {
      font-size: 1.1rem;
    }
    .column-item .name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .column-item .arrow {
      opacity: 0.5;
    }
    .column-header {
      padding: 8px 12px;
      font-size: 0.75rem;
      text-transform: uppercase;
      color: var(--text-secondary);
      background: rgba(0,0,0,0.2);
      font-weight: 600;
      letter-spacing: 0.5px;
    }
  </style>

  <!-- Context Menu for Folders -->
  <div id="folderContextMenu" class="context-menu" style="display: none;">
    <div class="context-menu-item" onclick="contextMenuRefresh()">
      <span></span> Refresh
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextMenuForceIndex()">
      <span></span> Force Full Index
    </div>
    <div class="context-menu-item" onclick="contextMenuForceThumbs()">
      <span></span> Force Regenerate Thumbnails
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextMenuShowStatus()">
      <span></span> Show Index Status...
    </div>
  </div>

  <!-- Context Menu for Assets -->
  <div id="assetContextMenu" class="context-menu" style="display: none;">
    <div class="context-menu-item" onclick="contextMenuViewAsset()">
      <span></span> View Details
    </div>
    <div class="context-menu-item" onclick="contextMenuDownloadAsset()">
      <span></span> Download
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextMenuReindexAsset()">
      <span></span> Re-index Asset
    </div>
    <div class="context-menu-item" onclick="contextMenuRegenThumb()">
      <span></span> Regenerate Thumbnail
    </div>
  </div>

  <!-- Context Menu for Breadcrumbs (in info panels) -->
  <div id="breadcrumbContextMenu" class="context-menu" style="display: none;">
    <div class="context-menu-item" onclick="breadcrumbContextNavigate()">
      <span></span> Go to Folder
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="breadcrumbContextForceIndex()">
      <span></span> Force Re-index Folder
    </div>
    <div class="context-menu-item" onclick="breadcrumbContextForceThumbs()">
      <span></span> Regenerate Thumbnails
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="breadcrumbContextShowStatus()">
      <span></span> Show Index Status...
    </div>
  </div>

  <style>
    .context-menu {
      position: fixed;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 0;
      min-width: 200px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      z-index: 10000;
    }
    .context-menu-item {
      padding: 10px 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--text-primary);
    }
    .context-menu-item:hover {
      background: var(--accent);
      color: white;
    }
    .context-menu-item span {
      width: 20px;
      text-align: center;
    }
    .context-menu-divider {
      border-top: 1px solid var(--border);
      margin: 4px 0;
    }
    @keyframes slideIn {
      from { transform: translateX(100px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
  </style>

  <script>
    let currentView = 'grid';
    let currentFolder = null;
    let currentPublisher = null;
    let currentSort = 'filename';
    let currentOrder = 'asc';
    let contentType = 'pdf';  // 'pdf' or '3d'
    let currentCollection = null;
    let currentFormat = null;  // STL, OBJ, 3MF filter for 3D models
    
    // Infinite scroll state for 3D models
    let modelsOffset = 0;
    let modelsLimit = 100;
    let modelsHasMore = true;
    let modelsLoading = false;
    let allLoadedModels = [];
    
    // Context menu state
    let contextMenuPath = null;
    let contextMenuAssetId = null;
    
    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      // Close context menus on click outside
      document.addEventListener('click', () => {
        document.getElementById('folderContextMenu').style.display = 'none';
        document.getElementById('assetContextMenu').style.display = 'none';
        document.getElementById('breadcrumbContextMenu').style.display = 'none';
      });
      
      // Add right-click handler for folder tree (PDFs)
      document.getElementById('folderTree').addEventListener('contextmenu', (e) => {
        const treeItem = e.target.closest('.tree-item');
        if (treeItem) {
          e.preventDefault();
          contextMenuPath = treeItem.dataset.path || null;
          showContextMenu('folderContextMenu', e.clientX, e.clientY);
        }
      });
      
      // Add right-click handler for 3D model folder tree
      document.getElementById('modelFolderTree').addEventListener('contextmenu', (e) => {
        const treeItem = e.target.closest('.tree-item');
        if (treeItem) {
          e.preventDefault();
          contextMenuPath = treeItem.dataset.path || null;
          showContextMenu('folderContextMenu', e.clientX, e.clientY);
        }
      });
      
      // Add right-click handler for asset cards (grid view) - event delegation
      document.getElementById('assetGrid').addEventListener('contextmenu', (e) => {
        const card = e.target.closest('.asset-card');
        if (card && card.dataset.id) {
          e.preventDefault();
          e.stopPropagation();
          contextMenuAssetId = parseInt(card.dataset.id, 10);
          contextMenuAssetType = card.dataset.type || (contentType === '3d' ? 'model' : 'pdf');
          showContextMenu('assetContextMenu', e.clientX, e.clientY);
        }
      });
      
      // Add right-click handler for asset rows (list view) - event delegation
      document.getElementById('assetList').addEventListener('contextmenu', (e) => {
        const row = e.target.closest('.asset-row');
        if (row && row.dataset.id) {
          e.preventDefault();
          e.stopPropagation();
          contextMenuAssetId = parseInt(row.dataset.id, 10);
          contextMenuAssetType = row.dataset.type || (contentType === '3d' ? 'model' : 'pdf');
          showContextMenu('assetContextMenu', e.clientX, e.clientY);
        }
      });
      
      // Add right-click handler for content search results (PDF search)
      document.getElementById('contentResults').addEventListener('contextmenu', (e) => {
        const card = e.target.closest('.asset-card');
        if (card && card.dataset.id) {
          e.preventDefault();
          e.stopPropagation();
          contextMenuAssetId = parseInt(card.dataset.id, 10);
          contextMenuAssetType = card.dataset.type || 'pdf';
          showContextMenu('assetContextMenu', e.clientX, e.clientY);
        }
      });
      loadStats();
      loadFolders();
      loadPublishers();
      loadAssets();
      // Pre-load 3D nav for quick switching
      load3dCollections();
      
      // Check if thumbnail rendering is already in progress
      checkThumbnailRenderStatus();
      load3dFolders();
      
      // Search
      let searchTimeout;
      document.getElementById('searchInput').addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => search(e.target.value), 300);
      });
      
      // View toggle
      document.querySelectorAll('.view-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentView = btn.dataset.view;
          toggleView();
        });
      });
      
      // Close modal on overlay click
      document.getElementById('modal').addEventListener('click', (e) => {
        if (e.target.id === 'modal') closeModal();
      });
      
      // Delegated click handler for folder navigation links in modals
      document.getElementById('modalBody').addEventListener('click', (e) => {
        const link = e.target.closest('.folder-nav-link');
        if (link) {
          e.preventDefault();
          const folder = link.dataset.folder;
          console.log('Folder link clicked:', folder);
          navigateToFolder(folder);
        }
      });
      
      // Close page preview on overlay click
      document.getElementById('pagePreview').addEventListener('click', (e) => {
        if (e.target.id === 'pagePreview') closePagePreview();
      });
      
      // Sort dropdown
      document.getElementById('sortSelect').addEventListener('change', changeSort);
      
      // Infinite scroll for 3D models
      const mainScroll = document.querySelector('.main-scroll');
      if (mainScroll) {
        mainScroll.addEventListener('scroll', () => {
          // Only trigger for 3D models view
          if (contentType !== '3d') return;
          
          // Check if near bottom (within 300px)
          const scrollHeight = mainScroll.scrollHeight;
          const scrollTop = mainScroll.scrollTop;
          const clientHeight = mainScroll.clientHeight;
          
          if (scrollHeight - scrollTop - clientHeight < 300) {
            // Load more if available and not already loading
            if (modelsHasMore && !modelsLoading) {
              console.log('Loading more models...', {offset: modelsOffset, hasMore: modelsHasMore});
              load3dModels(true); // append=true
            }
          }
        });
      } else {
        console.error('Infinite scroll: .main-scroll container not found');
      }
    });
    
    async function loadStats() {
      if (contentType === 'pdf') {
        const res = await fetch('/api/stats');
        const stats = await res.json();
        document.getElementById('stats').textContent = 
          `${stats.total_assets} PDFs  ${stats.total_size_gb} GB`;
      } else {
        const res = await fetch('/api/models/stats');
        const stats = await res.json();
        document.getElementById('stats').textContent = 
          `${stats.total_models} Models  ${stats.total_size_mb} MB`;
      }
    }
    
    function setContentType(type) {
      contentType = type;
      
      // Update toggle buttons
      document.getElementById('togglePdf').classList.toggle('active', type === 'pdf');
      document.getElementById('toggle3d').classList.toggle('active', type === '3d');
      
      // Update search placeholder
      document.getElementById('searchInput').placeholder = 
        type === 'pdf' ? 'Search PDFs...' : 'Search 3D models...';
      
      // Toggle nav sections
      document.getElementById('pdfNav').style.display = type === 'pdf' ? 'block' : 'none';
      document.getElementById('modelsNav').style.display = type === '3d' ? 'block' : 'none';
      
      // Show/hide format filter (only for 3D models)
      document.getElementById('formatFilter').style.display = type === '3d' ? 'inline-block' : 'none';
      
      // Clear current filters
      currentFolder = null;
      currentPublisher = null;
      currentCollection = null;
      currentFormat = null;
      document.getElementById('searchInput').value = '';
      document.getElementById('formatFilter').value = '';
      document.getElementById('contentResults').style.display = 'none';
      
      // Reload content
      loadStats();
      if (type === 'pdf') {
        loadFolders();
        loadAssets();
      } else {
        load3dFolders();
        load3dCollections();
        load3dModels();
      }
    }
    
    // 3D Model folder tree data
    let modelFolderTreeData = [];
    let expandedModelFolders = new Set();
    
    async function load3dCollections() {
      const res = await fetch('/api/models/collections');
      const collections = await res.json();
      
      const list = document.getElementById('collectionList');
      list.innerHTML = collections.map(c => `
        <li onclick="filter3dCollection('${escapeHtml(c.collection)}')" 
            class="${currentCollection === c.collection ? 'active' : ''}">
          ${escapeHtml(c.collection)}
          <span class="count-badge">${c.count}</span>
        </li>
      `).join('');
    }
    
    async function load3dFolders() {
      const res = await fetch('/api/models/folder-tree');
      const data = await res.json();
      const flat = data.flat || [];
      
      // Sort by path (natural tree order for renderLevel traversal)
      // This ensures parent-child hierarchy is preserved
      modelFolderTreeData = flat.sort((a, b) => a.path.localeCompare(b.path));
      
      render3dFolderTree();
    }
    
    function render3dFolderTree() {
      const container = document.getElementById('modelFolderTree');
      const totalCount = modelFolderTreeData.filter(f => f.depth === 0).reduce((a, f) => a + f.count, 0);
      
      // Build hierarchical HTML (same structure as PDF folder tree)
      let html = `
        <div class="tree-item ${!currentFolder ? 'active' : ''}" onclick="filter3dFolder(null)">
          <span class="toggle"></span>
          <span class="folder-name"> All Models</span>
          <span class="count-badge">${totalCount}</span>
        </div>
      `;
      
      const renderLevel = (items, parentDepth = -1) => {
        let result = '';
        let i = 0;
        while (i < items.length) {
          const item = items[i];
          if (item.depth <= parentDepth) break;
          if (item.depth === parentDepth + 1) {
            const hasChildren = item.hasChildren;
            const isExpanded = expandedModelFolders.has(item.path);
            const isActive = currentFolder === item.path;
            const indent = item.depth * 16;
            
            let childrenHtml = '';
            if (hasChildren && isExpanded) {
              // Only render children when expanded (lazy loading for performance)
              const childItems = [];
              let j = i + 1;
              while (j < items.length && items[j].depth > item.depth) {
                childItems.push(items[j]);
                j++;
              }
              childrenHtml = renderLevel(childItems, item.depth);
            }
            
            const jsPath = item.path.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            result += `
              <div style="padding-left: ${indent}px;">
                <div class="tree-item ${isActive ? 'active' : ''}" 
                     data-path="${escapeHtml(item.path)}"
                     onclick="handle3dTreeClick(event, '${jsPath}', ${hasChildren})">
                  <span class="toggle">${hasChildren ? (isExpanded ? '' : '') : ''}</span>
                  <span class="folder-name">${escapeHtml(item.name)}</span>
                  <span class="count-badge">${item.count}</span>
                </div>
                ${(hasChildren && isExpanded) ? `<div class="tree-children expanded" data-parent="${escapeHtml(item.path)}">${childrenHtml}</div>` : ''}
              </div>
            `;
          }
          i++;
        }
        return result;
      };
      
      html += renderLevel(modelFolderTreeData);
      container.innerHTML = html;
    }
    
    function handle3dTreeClick(event, path, hasChildren) {
      event.stopPropagation();
      const rect = event.currentTarget.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      
      if (hasChildren && clickX < 30) {
        if (expandedModelFolders.has(path)) {
          expandedModelFolders.delete(path);
        } else {
          expandedModelFolders.add(path);
        }
        render3dFolderTree();
      } else {
        filter3dFolder(path);
      }
    }
    
    function filter3dFolder(folder) {
      currentFolder = folder;
      currentCollection = null;  // Clear collection filter when filtering by folder
      
      // Auto-expand all parent folders to show path to current folder
      if (folder) {
        const parts = folder.split('/');
        for (let i = 1; i <= parts.length; i++) {
          const parentPath = parts.slice(0, i).join('/');
          expandedModelFolders.add(parentPath);
        }
      }
      
      load3dCollections();  // Update active states
      render3dFolderTree();
      load3dModels();
    }
    
    async function load3dModels(append = false) {
      if (modelsLoading) return;
      if (append && !modelsHasMore) return;
      
      modelsLoading = true;
      
      // Reset state if not appending (new filter/sort)
      if (!append) {
        modelsOffset = 0;
        modelsHasMore = true;
        allLoadedModels = [];
      }
      
      let url = `/api/models?limit=${modelsLimit}&offset=${modelsOffset}&sort=${currentSort}&order=${currentOrder}`;
      if (currentCollection) {
        url += `&collection=${encodeURIComponent(currentCollection)}`;
      }
      if (currentFolder) {
        url += `&folder=${encodeURIComponent(currentFolder)}`;
      }
      if (currentFormat) {
        url += `&format=${encodeURIComponent(currentFormat)}`;
      }
      
      try {
        const res = await fetch(url);
        const models = await res.json();
        
        // Check if we got fewer results than requested (end of data)
        if (models.length < modelsLimit) {
          modelsHasMore = false;
        }
        
        // Update offset for next load
        modelsOffset += models.length;
        
        // Append to all loaded models
        if (append) {
          allLoadedModels = allLoadedModels.concat(models);
        } else {
          allLoadedModels = models;
        }
        
        render3dModels(allLoadedModels, append);
      } finally {
        modelsLoading = false;
      }
    }
    
    function changeFormatFilter() {
      currentFormat = document.getElementById('formatFilter').value || null;
      load3dModels();
    }
    
    function filter3dCollection(collection) {
      currentCollection = collection;
      currentFolder = null;  // Clear folder filter when filtering by collection
      load3dCollections();
      render3dFolderTree();
      load3dModels();
    }
    
    function render3dModels(models, append = false) {
      const grid = document.getElementById('assetGrid');
      const list = document.getElementById('assetList');
      
      if (models.length === 0 && !append) {
        grid.innerHTML = `
          <div class="empty-state">
            <h3>No 3D models found</h3>
            <p>Index your 3D files from Settings</p>
          </div>
        `;
        list.innerHTML = '';
        return;
      }
      
      // Grid view with preview thumbnails (fresh timestamp for immediate updates)
      const cacheBust = Date.now();
      const gridHtml = models.map(m => `
        <div class="asset-card" data-id="${m.id}" data-type="model" onclick="show3dDetail(${m.id})" title="ID: ${m.id}">
          <img class="asset-thumb model-grid-thumb" data-model-id="${m.id}" src="/api/models/${m.id}/preview?t=${cacheBust}" alt="" loading="lazy" 
               onerror="console.error('Thumb failed for model ${m.id}:', this.src); this.src='/static/placeholder-3d.svg';" />
          <div class="asset-info">
            <div class="asset-title" title="${escapeHtml(m.filename)}">${escapeHtml(m.title || m.filename)}</div>
            <div class="asset-meta">${(m.format || 'stl').toUpperCase()}  ${formatSize(m.file_size)}  #${m.id}</div>
          </div>
        </div>
      `).join('');
      
      // Append or replace grid content
      if (append) {
        grid.innerHTML += gridHtml;
      } else {
        grid.innerHTML = gridHtml;
      }
      
      // List view
      const listHtml = models.map(m => `
        <div class="asset-row" data-id="${m.id}" data-type="model" onclick="show3dDetail(${m.id})">
          <img data-model-id="${m.id}" src="/api/models/${m.id}/preview?t=${cacheBust}" alt="" loading="lazy" 
               onerror="this.outerHTML='<div class=\\'model-icon-small\\'></div>'" />
          <div>
            <div class="title">${escapeHtml(m.title || m.filename)}</div>
            <div class="publisher">${escapeHtml(m.collection || '')}</div>
          </div>
          <div class="publisher">${(m.format || 'stl').toUpperCase()}</div>
          <div class="pages">${m.has_supports ? ' Supported' : ''}</div>
          <div class="size">${formatSize(m.file_size)}</div>
        </div>
      `).join('');
      
      // Append or replace list content
      if (append) {
        list.innerHTML += listHtml;
      } else {
        list.innerHTML = listHtml;
      }
    }
    
    // Current model for 3D viewer
    let current3dModelId = null;
    let threeViewer = null;
    
    async function show3dDetail(id) {
      current3dModelId = id;
      const res = await fetch(`/api/models/${id}`);
      const model = await res.json();
      
      // Determine if this is a 3D model or 2D asset (SVG)
      const isSvg = (model.format || '').toLowerCase() === 'svg';
      const is3d = !isSvg && ['stl', 'obj', '3mf', 'glb', 'gltf'].includes((model.format || '').toLowerCase());
      
      // Use same structure as PDF modal for consistency
      document.getElementById('modalBody').innerHTML = `
        <div class="model-preview-area">
          <img class="model-thumb-img" src="/api/models/${id}/preview" alt="" 
               onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" />
          <div class="model-thumb-fallback" style="display:none;">${isSvg ? '' : ''}</div>
          ${is3d ? `
          <div id="viewer3d" class="viewer-3d"></div>
          <div class="viewer-controls" id="viewerControls">
            <button onclick="resetViewer()" title="Reset view"></button>
            <button onclick="toggleWireframe()" title="Toggle wireframe"></button>
            <button onclick="close3dViewer()" title="Close 3D view"></button>
          </div>
          ` : ''}
          ${isSvg ? `
          <div id="svgViewer" class="viewer-3d" style="display:none; background:#fff; padding:20px;">
            <img src="/api/models/${id}/file" style="max-width:100%; max-height:100%; object-fit:contain;" alt="SVG" />
          </div>
          <div class="viewer-controls" id="svgViewerControls" style="display:none;">
            <button onclick="closeSvgViewer()" title="Close SVG view"></button>
          </div>
          ` : ''}
        </div>
        <div class="modal-details">
          <h2>${escapeHtml(model.title || model.filename)}</h2>
          
          <div class="detail-row">
            <span class="detail-label">Filename</span>
            <span class="detail-value">${escapeHtml(model.filename)}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Format</span>
            <span class="detail-value">${(model.format || 'stl').toUpperCase()}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Collection</span>
            <span class="detail-value">${escapeHtml(model.collection || '')}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">File Size</span>
            <span class="detail-value">${formatSize(model.file_size)}</span>
          </div>
          ${!isSvg ? `
          <div class="detail-row">
            <span class="detail-label">Supports</span>
            <span class="detail-value">${model.has_supports ? ' Pre-supported' : 'No'}</span>
          </div>
          ` : ''}
          ${model.folder_path ? `
          <div class="detail-row">
            <span class="detail-label">Location</span>
            <span class="detail-value breadcrumbs"> ${renderBreadcrumbs(model.folder_path)}</span>
          </div>
          ` : ''}
          ${model.archive_path ? `
          <div class="detail-row">
            <span class="detail-label">Archive</span>
            <span class="detail-value" style="font-size:0.8rem"> ${escapeHtml(model.archive_path.split('/').pop())}</span>
          </div>
          ` : ''}
          
          <div class="modal-actions">
            ${is3d ? `
            <button class="btn btn-secondary" onclick="open3dViewer(${id})" id="btn3dPreview">
               3D Preview
            </button>
            ` : ''}
            ${isSvg ? `
            <button class="btn btn-secondary" onclick="openSvgViewer(${id})" id="btnSvgPreview">
               View Full Size
            </button>
            ` : ''}
            <button class="btn btn-primary" onclick="downloadModel(${id}, '${model.filename?.replace(/'/g, "\\'")}')">
               Download
            </button>
          </div>
        </div>
      `;
      
      document.getElementById('modal').classList.add('active');
    }
    
    // Three.js viewer state
    let threeJsLoaded = false;
    
    // Three.js viewer functions
    let loadedLoaders = { stl: false, obj: false, '3mf': false, glb: false, gltf: false };
    
    async function open3dViewer(modelId) {
      const btn = document.getElementById('btn3dPreview');
      if (btn) btn.textContent = ' Loading...';
      
      try {
        // Get model info to determine format
        const res = await fetch(`/api/models/${modelId}`);
        const model = await res.json();
        const format = (model.format || 'stl').toLowerCase();
        
        // Check if Three.js is loaded
        if (!threeJsLoaded) {
          // Load Three.js, controls, and fflate (needed for 3MF) from CDN
          await loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js');
          await loadScript('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js');
          await loadScript('https://cdn.jsdelivr.net/npm/fflate@0.8.0/umd/index.js');
          threeJsLoaded = true;
        }
        
        // Load format-specific loader
        if (format === 'stl' && !loadedLoaders.stl) {
          await loadScript('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/STLLoader.js');
          loadedLoaders.stl = true;
        } else if (format === 'obj' && !loadedLoaders.obj) {
          await loadScript('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/OBJLoader.js');
          loadedLoaders.obj = true;
        } else if (format === '3mf' && !loadedLoaders['3mf']) {
          // fflate already loaded with Three.js base
          await loadScript('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/3MFLoader.js');
          loadedLoaders['3mf'] = true;
        } else if ((format === 'glb' || format === 'gltf') && !loadedLoaders.glb) {
          await loadScript('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js');
          loadedLoaders.glb = true;
          loadedLoaders.gltf = true;
        }
        
        // Hide static preview, show 3D viewer
        const previewImg = document.querySelector('.model-preview-area .model-thumb-img');
        const fallback = document.querySelector('.model-preview-area .model-thumb-fallback');
        const viewerDiv = document.getElementById('viewer3d');
        const controls = document.getElementById('viewerControls');
        
        if (previewImg) previewImg.style.display = 'none';
        if (fallback) fallback.style.display = 'none';
        if (viewerDiv) viewerDiv.style.display = 'block';
        if (controls) controls.style.display = 'flex';
        
        if (btn) btn.style.display = 'none';
        
        // Initialize Three.js scene with format info
        if (viewerDiv) init3dViewer(viewerDiv, modelId, format);
      } catch (e) {
        console.error('Failed to load Three.js:', e);
        if (btn) btn.textContent = ' Load failed';
      }
    }
    
    function openSvgViewer(modelId) {
      const btn = document.getElementById('btnSvgPreview');
      const previewImg = document.querySelector('.model-preview-area .model-thumb-img');
      const fallback = document.querySelector('.model-preview-area .model-thumb-fallback');
      const svgViewer = document.getElementById('svgViewer');
      const svgControls = document.getElementById('svgViewerControls');
      
      // Hide thumbnail, show full SVG
      if (previewImg) previewImg.style.display = 'none';
      if (fallback) fallback.style.display = 'none';
      if (svgViewer) svgViewer.style.display = 'flex';
      if (svgControls) svgControls.style.display = 'flex';
      if (btn) btn.style.display = 'none';
    }
    
    function closeSvgViewer() {
      const previewImg = document.querySelector('.model-preview-area .model-thumb-img');
      const fallback = document.querySelector('.model-preview-area .model-thumb-fallback');
      const svgViewer = document.getElementById('svgViewer');
      const svgControls = document.getElementById('svgViewerControls');
      const btn = document.getElementById('btnSvgPreview');
      
      if (svgViewer) svgViewer.style.display = 'none';
      if (svgControls) svgControls.style.display = 'none';
      if (previewImg) previewImg.style.display = 'block';
      if (fallback && !previewImg) fallback.style.display = 'flex';
      if (btn) btn.style.display = 'inline-block';
    }
    
    function close3dViewer() {
      const previewImg = document.querySelector('.model-preview-area .model-thumb-img');
      const fallback = document.querySelector('.model-preview-area .model-thumb-fallback');
      const viewerDiv = document.getElementById('viewer3d');
      const controls = document.getElementById('viewerControls');
      const btn = document.getElementById('btn3dPreview');
      
      if (viewerDiv) {
        viewerDiv.style.display = 'none';
        viewerDiv.innerHTML = '';
      }
      if (controls) controls.style.display = 'none';
      
      if (previewImg) previewImg.style.display = 'block';
      else if (fallback) fallback.style.display = 'flex';
      
      if (btn) {
        btn.style.display = 'inline-block';
        btn.textContent = ' 3D Preview';
      }
      
      threeViewer = null;
    }
    
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        // Check if already loaded
        if (document.querySelector(`script[src="${src}"]`)) {
          resolve();
          return;
        }
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    
    function init3dViewer(container, modelId, format = 'stl') {
      // Clear any previous viewer
      container.innerHTML = '';
      
      const width = container.clientWidth || 200;
      const height = container.clientHeight || 200;
      
      // Check Three.js loaded properly
      if (typeof THREE === 'undefined') {
        console.error('THREE not loaded');
        container.innerHTML = '<div style="color:red;padding:20px;">Three.js failed to load</div>';
        return;
      }
      
      // Check format-specific loader
      const loaderCheck = {
        'stl': () => typeof THREE.STLLoader !== 'undefined',
        'obj': () => typeof THREE.OBJLoader !== 'undefined',
        '3mf': () => typeof THREE.ThreeMFLoader !== 'undefined',
        'glb': () => typeof THREE.GLTFLoader !== 'undefined',
        'gltf': () => typeof THREE.GLTFLoader !== 'undefined'
      };
      
      if (!loaderCheck[format] || !loaderCheck[format]()) {
        console.error(`${format.toUpperCase()} Loader not loaded`);
        container.innerHTML = `<div style="color:red;padding:20px;">${format.toUpperCase()} Loader failed to load</div>`;
        return;
      }
      
      // Scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);
      
      // Camera
      const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
      camera.position.set(0, 50, 100);
      
      // Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);
      
      // Controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      
      // Lights
      const ambientLight = new THREE.AmbientLight(0x404040, 2);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
      directionalLight.position.set(50, 100, 50);
      scene.add(directionalLight);
      
      const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
      backLight.position.set(-50, 50, -50);
      scene.add(backLight);
      
      // Grid
      const gridHelper = new THREE.GridHelper(100, 10, 0x4dabf7, 0x333366);
      scene.add(gridHelper);
      
      // Show loading indicator
      const loadingDiv = document.createElement('div');
      loadingDiv.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#4dabf7;';
      loadingDiv.textContent = ' Loading...';
      container.appendChild(loadingDiv);
      
      // Create format-specific loader
      let loader;
      if (format === 'stl') {
        loader = new THREE.STLLoader();
      } else if (format === 'obj') {
        loader = new THREE.OBJLoader();
      } else if (format === '3mf') {
        loader = new THREE.ThreeMFLoader();
      } else if (format === 'glb' || format === 'gltf') {
        loader = new THREE.GLTFLoader();
      }
      
      // Material for the model
      const material = new THREE.MeshPhongMaterial({ 
        color: 0x4dabf7,
        specular: 0x111111,
        shininess: 30,
        flatShading: false
      });
      
      // Load model file
      loader.load(
        `/api/models/${modelId}/file`,
        (result) => {
          loadingDiv.remove();
          
          let mesh;
          
          if (format === 'stl') {
            // STLLoader returns geometry
            mesh = new THREE.Mesh(result, material);
          } else if (format === 'glb' || format === 'gltf') {
            // GLTFLoader returns { scene, animations, cameras, etc. }
            mesh = result.scene;
            // GLTF models have their own materials, optionally override
            // mesh.traverse((child) => {
            //   if (child.isMesh) {
            //     child.material = material;
            //   }
            // });
          } else if (format === 'obj' || format === '3mf') {
            // OBJLoader and 3MFLoader return Object3D/Group
            mesh = result;
            // Apply material to all meshes in the group
            mesh.traverse((child) => {
              if (child.isMesh) {
                child.material = material;
              }
            });
          }
          
          // Compute bounding box for any format
          const bbox = new THREE.Box3().setFromObject(mesh);
          const center = new THREE.Vector3();
          bbox.getCenter(center);
          mesh.position.sub(center);
          
          // Auto-scale to fit view
          const size = new THREE.Vector3();
          bbox.getSize(size);
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 50 / maxDim;
          mesh.scale.set(scale, scale, scale);
          
          // Position on grid
          const newBbox = new THREE.Box3().setFromObject(mesh);
          mesh.position.y = -newBbox.min.y;
          
          scene.add(mesh);
          
          // Store for controls
          threeViewer = { scene, camera, renderer, controls, mesh, material };
          
          // Fit camera
          camera.position.set(maxDim * scale, maxDim * scale, maxDim * scale * 1.5);
          controls.target.set(0, 25, 0);
          controls.update();
      },
      // Progress callback
      (xhr) => {
        if (xhr.lengthComputable) {
          const pct = Math.round(xhr.loaded / xhr.total * 100);
          loadingDiv.textContent = ` Loading ${pct}%`;
        }
      },
      // Error callback
      (error) => {
        console.error(`3D model load error (${format}):`, error);
        loadingDiv.textContent = ` Failed to load ${format.toUpperCase()} model`;
        loadingDiv.style.color = '#ff6b6b';
      }
      );
      
      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
      
      // Handle resize
      const resizeObserver = new ResizeObserver(() => {
        const w = container.clientWidth;
        const h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
      resizeObserver.observe(container);
    }
    
    function resetViewer() {
      if (threeViewer) {
        const { camera, controls, mesh } = threeViewer;
        camera.position.set(50, 50, 75);
        controls.target.set(0, 25, 0);
        controls.update();
      }
    }
    
    function toggleWireframe() {
      if (threeViewer && threeViewer.material) {
        threeViewer.material.wireframe = !threeViewer.material.wireframe;
      }
    }
    
    let expandedFolders = new Set();
    let folderTreeData = [];
    
    async function loadFolders() {
      const res = await fetch('/api/folder-tree');
      const data = await res.json();
      const flat = data.flat || [];
      
      // Sort by path (natural tree order for renderLevel traversal)
      // This ensures parent-child hierarchy is preserved in depth-first order
      folderTreeData = flat.sort((a, b) => a.path.localeCompare(b.path));
      
      renderFolderTree();
    }
    
    function renderFolderTree() {
      const container = document.getElementById('folderTree');
      const totalCount = folderTreeData.filter(f => f.depth === 0).reduce((a, f) => a + f.count, 0);
      
      // Build hierarchical HTML
      let html = `
        <div class="tree-item ${!currentFolder ? 'active' : ''}" onclick="filterFolder(null)">
          <span class="toggle"></span>
          <span class="folder-name"> All Files</span>
          <span class="count-badge">${totalCount}</span>
        </div>
      `;
      
      // Group items by parent path for tree rendering
      const renderLevel = (items, parentDepth = -1) => {
        let result = '';
        let i = 0;
        while (i < items.length) {
          const item = items[i];
          if (item.depth <= parentDepth) break;
          if (item.depth === parentDepth + 1) {
            const hasChildren = item.hasChildren;
            const isExpanded = expandedFolders.has(item.path);
            const isActive = currentFolder === item.path;
            const indent = item.depth * 16;
            
            // Find children
            let childrenHtml = '';
            if (hasChildren && isExpanded) {
              // Only render children when expanded (lazy loading for performance)
              const childItems = [];
              let j = i + 1;
              while (j < items.length && items[j].depth > item.depth) {
                childItems.push(items[j]);
                j++;
              }
              childrenHtml = renderLevel(childItems, item.depth);
            }
            
            const jsPath = item.path.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            result += `
              <div style="padding-left: ${indent}px;">
                <div class="tree-item ${isActive ? 'active' : ''}" 
                     data-path="${escapeHtml(item.path)}"
                     onclick="handleTreeClick(event, '${jsPath}', ${hasChildren})">
                  <span class="toggle">${hasChildren ? (isExpanded ? '' : '') : ''}</span>
                  <span class="folder-name">${escapeHtml(item.name)}</span>
                  <span class="count-badge">${item.count}</span>
                </div>
                ${(hasChildren && isExpanded) ? `<div class="tree-children expanded" data-parent="${escapeHtml(item.path)}">${childrenHtml}</div>` : ''}
              </div>
            `;
          }
          i++;
        }
        return result;
      };
      
      html += renderLevel(folderTreeData);
      container.innerHTML = html;
    }
    
    function handleTreeClick(event, path, hasChildren) {
      event.stopPropagation();
      
      // If clicking toggle area or has children, toggle expand
      const rect = event.currentTarget.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      
      if (hasChildren && clickX < 30) {
        // Toggle expansion
        if (expandedFolders.has(path)) {
          expandedFolders.delete(path);
        } else {
          expandedFolders.add(path);
        }
        renderFolderTree();
      } else {
        // Filter by this folder
        filterFolder(path);
      }
    }
    
    async function loadPublishers() {
      const res = await fetch('/api/publishers');
      const publishers = await res.json();
      const list = document.getElementById('publisherList');
      
      list.innerHTML = publishers.slice(0, 15).map(p => `
        <li class="${currentPublisher === p.publisher ? 'active' : ''}"
            onclick="filterPublisher('${p.publisher}')">
          ${p.publisher || 'Unknown'}
          <span class="count-badge">${p.count}</span>
        </li>
      `).join('');
    }
    
    async function loadAssets() {
      let url = `/api/assets?limit=100&sort=${currentSort}&order=${currentOrder}`;
      if (currentFolder) url += `&folder=${encodeURIComponent(currentFolder)}`;
      if (currentPublisher) url += `&publisher=${encodeURIComponent(currentPublisher)}`;
      
      const res = await fetch(url);
      const assets = await res.json();
      renderAssets(assets);
      toggleView();
    }
    
    function changeSort() {
      const val = document.getElementById('sortSelect').value;
      const [sort, order] = val.split(':');
      currentSort = sort;
      currentOrder = order;
      
      if (lastSearchQuery) {
        search(lastSearchQuery);
      } else if (contentType === '3d') {
        load3dModels();
      } else {
        loadAssets();
      }
    }
    
    function clearFilters() {
      currentFolder = null;
      currentPublisher = null;
      currentCollection = null;
      currentFormat = null;
      currentSort = 'filename';
      currentOrder = 'asc';
      document.getElementById('searchInput').value = '';
      document.getElementById('sortSelect').value = 'filename:asc';
      document.getElementById('formatFilter').value = '';
      document.getElementById('contentResults').style.display = 'none';
      lastSearchQuery = '';
      
      // Load content based on current view type
      if (contentType === '3d') {
        load3dFolders();
        load3dCollections();
        load3dModels();
      } else {
        loadFolders();
        loadPublishers();
        loadAssets();
      }
    }
    
    function goHome() {
      clearFilters();
      clearAdvancedSearch();
    }
    
    let searchTermCount = 1;
    
    function toggleAdvancedSearch() {
      const panel = document.getElementById('advancedSearchPanel');
      const btn = document.querySelector('.adv-search-toggle');
      panel.classList.toggle('open');
      btn.classList.toggle('active');
      
      // Update scope option when opening
      if (panel.classList.contains('open')) {
        updateScopeOption();
      }
    }
    
    function updateScopeOption() {
      const scopeOption = document.getElementById('advScopeCurrent');
      if (currentFolder) {
        const folderName = currentFolder.split('/').pop();
        scopeOption.textContent = `Current: ${folderName}`;
        scopeOption.disabled = false;
      } else {
        scopeOption.textContent = 'Current folder (select a folder first)';
        scopeOption.disabled = true;
        document.getElementById('advSearchScope').value = 'all';
      }
    }
    
    function addSearchTerm() {
      const container = document.getElementById('advSearchTerms');
      const rowNum = searchTermCount++;
      
      const row = document.createElement('div');
      row.className = 'adv-term-row';
      row.dataset.row = rowNum;
      row.innerHTML = `
        <select class="term-operator">
          <option value="AND">AND</option>
          <option value="OR">OR</option>
        </select>
        <span class="term-label">in</span>
        <select class="term-field">
          <option value="all">Title & Content</option>
          <option value="title">Title only</option>
          <option value="content">Content only</option>
        </select>
        <select class="term-include">
          <option value="include">contains</option>
          <option value="exclude">does NOT contain</option>
        </select>
        <input type="text" class="term-input" placeholder="Enter search term..." />
        <button class="term-remove" onclick="removeSearchTerm(${rowNum})"></button>
      `;
      container.appendChild(row);
    }
    
    function removeSearchTerm(rowNum) {
      const row = document.querySelector(`.adv-term-row[data-row="${rowNum}"]`);
      if (row) row.remove();
    }
    
    function clearAdvancedSearch() {
      document.getElementById('advSearchScope').value = 'all';
      document.getElementById('advSearchFormat').value = '';
      
      // Reset to single search term
      const container = document.getElementById('advSearchTerms');
      container.innerHTML = `
        <div class="adv-term-row" data-row="0">
          <span class="term-label">Find in</span>
          <select class="term-field">
            <option value="all">Title & Content</option>
            <option value="title">Title only</option>
            <option value="content">Content only</option>
          </select>
          <select class="term-include">
            <option value="include">contains</option>
            <option value="exclude">does NOT contain</option>
          </select>
          <input type="text" class="term-input" placeholder="Enter search term..." />
        </div>
      `;
      searchTermCount = 1;
    }
    
    function buildAdvancedQuery() {
      const rows = document.querySelectorAll('.adv-term-row');
      const terms = [];
      
      rows.forEach((row, i) => {
        const input = row.querySelector('.term-input');
        const include = row.querySelector('.term-include');
        const operator = row.querySelector('.term-operator');
        const field = row.querySelector('.term-field');
        
        const term = input.value.trim();
        if (!term) return;
        
        const isExclude = include.value === 'exclude';
        const op = operator ? operator.value : 'AND';
        const searchField = field ? field.value : 'all';
        
        terms.push({
          term: term,
          exclude: isExclude,
          operator: op,
          field: searchField
        });
      });
      
      return terms;
    }
    
    async function runAdvancedSearch() {
      const terms = buildAdvancedQuery();
      if (terms.length === 0) return;
      
      const scope = document.getElementById('advSearchScope').value;
      const folder = (scope === 'current' && currentFolder) ? currentFolder : null;
      const format = document.getElementById('advSearchFormat').value;
      
      // Build search request
      const searchParams = new URLSearchParams();
      searchParams.set('terms', JSON.stringify(terms));
      searchParams.set('content_type', contentType);  // Tell backend which tab we're on
      if (folder) searchParams.set('folder', folder);
      if (format) searchParams.set('format', format);
      
      const res = await fetch(`/api/search/advanced?${searchParams}`);
      const results = await res.json();
      
      // Update search input to show query summary
      const queryDisplay = terms.map(t => {
        let s = '';
        if (t.operator && terms.indexOf(t) > 0) s += t.operator + ' ';
        if (t.exclude) s += 'NOT ';
        s += `"${t.term}"`;
        if (t.field !== 'all') s += ` (${t.field})`;
        return s;
      }).join(' ');
      document.getElementById('searchInput').value = queryDisplay;
      lastSearchQuery = queryDisplay;
      
      // Render results based on CURRENT content type (don't auto-switch tabs)
      if (contentType === '3d') {
        // Show 3D model results only
        render3dModels(results.models || []);
        document.getElementById('contentResults').style.display = 'none';
      } else {
        // Show PDF results only (assets + pages)
        renderAssets(results.assets || results.metadata || []);
        renderContentResults(results.pages || results.content || [], queryDisplay);
      }
      toggleView();
    }
    
    function getAdvancedFilters() {
      return {
        scope: document.getElementById('advSearchScope')?.value || 'all',
        field: 'all',  // Title + Content by default
        publisher: null,
        gameSystem: null
      };
    }
    
    let lastSearchQuery = '';
    
    async function search(query) {
      if (!query) {
        lastSearchQuery = '';
        searchMatchesByAsset = {};
        document.getElementById('contentResults').style.display = 'none';
        
        // Load appropriate content type
        if (contentType === '3d') {
          load3dModels();
        } else {
          loadAssets();
        }
        return;
      }
      
      lastSearchQuery = query;
      
      // Different search for 3D models vs PDFs
      if (contentType === '3d') {
        const adv = getAdvancedFilters();
        let searchUrl = `/api/models/search?q=${encodeURIComponent(query)}`;
        
        // Scope search to current folder if selected
        if (adv.scope === 'current' && currentFolder) {
          searchUrl += `&folder=${encodeURIComponent(currentFolder)}`;
        }
        
        const res = await fetch(searchUrl);
        const models = await res.json();
        document.getElementById('contentResults').style.display = 'none';
        render3dModels(models);
        toggleView();
        return;
      }
      
      // PDF search with advanced filters
      const adv = getAdvancedFilters();
      let searchUrl = `/api/search/all?q=${encodeURIComponent(query)}`;
      
      // Scope search to current folder if selected
      if (adv.scope === 'current' && currentFolder) {
        searchUrl += `&folder=${encodeURIComponent(currentFolder)}`;
      }
      if (adv.field !== 'all') {
        searchUrl += `&field=${adv.field}`;
      }
      if (adv.publisher) {
        searchUrl += `&publisher=${encodeURIComponent(adv.publisher)}`;
      }
      if (adv.gameSystem) {
        searchUrl += `&system=${encodeURIComponent(adv.gameSystem)}`;
      }
      
      const res = await fetch(searchUrl);
      const results = await res.json();
      
      // API returns 'assets' and 'pages', map to expected keys
      const assets = results.assets || results.metadata || [];
      const pages = results.pages || results.content || [];
      
      // Sort metadata results client-side
      let sortedMetadata = sortResults(assets);
      
      // Render metadata matches (or show message if empty)
      if (sortedMetadata.length === 0 && pages.length > 0) {
        // Only content matches, no title/filename matches
        document.getElementById('assetGrid').innerHTML = '';
        document.getElementById('assetList').innerHTML = '';
      } else {
        renderAssets(sortedMetadata);
      }
      
      // Render content matches with page numbers (sorted)
      renderContentResults(pages, query);
      
      // Ensure view toggle is applied
      toggleView();
    }
    
    function sortResults(assets) {
      if (!assets || assets.length === 0) return assets;
      
      const sorted = [...assets];
      sorted.sort((a, b) => {
        let valA = a[currentSort];
        let valB = b[currentSort];
        
        // Handle nulls
        if (valA == null) valA = '';
        if (valB == null) valB = '';
        
        // String comparison for text fields
        if (typeof valA === 'string') {
          valA = valA.toLowerCase();
          valB = (valB || '').toLowerCase();
        }
        
        let result = 0;
        if (valA < valB) result = -1;
        if (valA > valB) result = 1;
        
        return currentOrder === 'desc' ? -result : result;
      });
      
      return sorted;
    }
    
    function renderContentResults(results, query) {
      const container = document.getElementById('contentResults');
      
      if (!results || results.length === 0) {
        container.style.display = 'none';
        searchMatchesByAsset = {};  // Clear search matches
        return;
      }
      
      // Group by asset
      const byAsset = {};
      results.forEach(r => {
        if (!byAsset[r.asset_id]) {
          byAsset[r.asset_id] = {
            asset_id: r.asset_id,
            title: r.title,
            filename: r.filename,
            folder_path: r.folder_path,
            publisher: r.publisher,
            pages: []
          };
        }
        byAsset[r.asset_id].pages.push({
          page_num: r.page_num,
          snippet: r.snippet
        });
      });
      
      // Store matches for detail modal access
      searchMatchesByAsset = {};
      Object.values(byAsset).forEach(a => {
        searchMatchesByAsset[a.asset_id] = a.pages;
      });
      
      // Sort the grouped assets
      let assets = Object.values(byAsset);
      assets.sort((a, b) => {
        let valA = a[currentSort] || a.filename;
        let valB = b[currentSort] || b.filename;
        if (typeof valA === 'string') {
          valA = valA.toLowerCase();
          valB = (valB || '').toLowerCase();
        }
        let result = valA < valB ? -1 : (valA > valB ? 1 : 0);
        return currentOrder === 'desc' ? -result : result;
      });
      
      // Grid view for content results
      const gridHtml = assets.map(a => `
        <div class="asset-card" data-id="${a.asset_id}" data-type="pdf" onclick="showDetail(${a.asset_id})">
          <img class="asset-thumb" src="/api/thumbnail/${a.asset_id}" alt="" loading="lazy" />
          <div class="asset-info">
            <div class="asset-title" title="${escapeHtml(a.title || a.filename)}">${escapeHtml(a.title || a.filename)}</div>
            <div class="asset-meta">${a.pages.length} page matches</div>
          </div>
        </div>
      `).join('');
      
      // List view for content results
      const listHtml = assets.map(a => `
        <div class="content-result-card">
          <div class="content-result-header">
            <img src="/api/thumbnail/${a.asset_id}" alt="" onclick="showDetail(${a.asset_id})" />
            <div>
              <div class="title" onclick="showDetail(${a.asset_id})" style="cursor:pointer">${escapeHtml(a.title || a.filename)}</div>
              <div class="path breadcrumbs">${renderBreadcrumbs(a.folder_path)}</div>
            </div>
          </div>
          <div class="page-matches">
            ${a.pages.slice(0, 5).map(p => `
              <div class="page-match" onclick="openToPage(${a.asset_id}, ${p.page_num})">
                <span class="page-num">p.${p.page_num}</span>
                <span class="snippet">${p.snippet}</span>
              </div>
            `).join('')}
            ${a.pages.length > 5 ? `<div class="more-pages">+${a.pages.length - 5} more pages</div>` : ''}
          </div>
        </div>
      `).join('');
      
      container.innerHTML = `
        <h3> Content Matches (${results.length} pages in ${assets.length} PDFs)</h3>
        <div class="content-grid ${currentView === 'grid' ? '' : 'hidden'}">${gridHtml}</div>
        <div class="content-list ${currentView === 'list' ? '' : 'hidden'}">${listHtml}</div>
      `;
      container.style.display = 'block';
    }
    
    function renderAssets(assets) {
      const grid = document.getElementById('assetGrid');
      const list = document.getElementById('assetList');
      
      if (assets.length === 0) {
        grid.innerHTML = `
          <div class="empty-state">
            <h3>No PDFs found</h3>
            <p>Run the indexer to scan your PDF collection</p>
          </div>
        `;
        list.innerHTML = '';
        return;
      }
      
      // Grid view (with cache-busting for fresh thumbnails)
      const cacheBust = Date.now();
      grid.innerHTML = assets.map(a => `
        <div class="asset-card" data-id="${a.id}" data-type="pdf" onclick="showDetail(${a.id})">
          <img class="asset-thumb" src="/api/thumbnail/${a.id}?t=${cacheBust}" alt="" loading="lazy" />
          <div class="asset-info">
            <div class="asset-title" title="${escapeHtml(a.title || a.filename)}">${escapeHtml(a.title || a.filename)}</div>
            <div class="asset-meta">${a.page_count || '?'} pages</div>
          </div>
        </div>
      `).join('');
      
      // List view
      list.innerHTML = assets.map(a => `
        <div class="asset-row" data-id="${a.id}" data-type="pdf" onclick="showDetail(${a.id})">
          <img src="/api/thumbnail/${a.id}?t=${cacheBust}" alt="" loading="lazy" />
          <div>
            <div class="title">${escapeHtml(a.title || a.filename)}</div>
            <div class="publisher">${escapeHtml(a.publisher || '')}</div>
          </div>
          <div class="publisher">${escapeHtml(a.game_system || '')}</div>
          <div class="pages">${a.page_count || '?'} pages</div>
          <div class="size">${formatSize(a.file_size)}</div>
        </div>
      `).join('');
    }
    
    function filterFolder(folder) {
      // Clear search state
      lastSearchQuery = '';
      searchMatchesByAsset = {};
      document.getElementById('searchInput').value = '';
      document.getElementById('contentResults').style.display = 'none';
      
      currentFolder = folder;
      currentPublisher = null;
      currentCollection = null;
      
      // Auto-expand all parent folders to show path to current folder
      if (folder) {
        const parts = folder.split('/');
        for (let i = 1; i <= parts.length; i++) {
          const parentPath = parts.slice(0, i).join('/');
          expandedFolders.add(parentPath);
        }
      }
      
      loadFolders();
      loadPublishers();
      
      // Load assets based on current mode
      if (contentType === '3d') {
        load3dModels();
      } else {
        loadAssets();
      }
      updateScopeOption();
    }
    
    function filterPublisher(publisher) {
      // Clear search state
      lastSearchQuery = '';
      searchMatchesByAsset = {};
      document.getElementById('searchInput').value = '';
      document.getElementById('contentResults').style.display = 'none';
      
      currentPublisher = publisher;
      loadPublishers();
      loadAssets();
    }
    
    // Store search matches by asset ID for display in detail modal
    let searchMatchesByAsset = {};
    
    async function showDetail(id) {
      bookmarksLoaded = false;  // Reset for new asset
      const res = await fetch(`/api/assets/${id}`);
      const asset = await res.json();
      
      // Check if we have search matches for this asset
      const matches = searchMatchesByAsset[id] || [];
      let searchMatchesHtml = '';
      
      if (matches.length > 0) {
        searchMatchesHtml = `
          <div class="search-matches-section">
            <h4> Search Matches (${matches.length} pages)</h4>
            <div class="search-matches-list">
              ${matches.map(m => `
                <div class="page-match" onclick="closeModal(); openToPage(${id}, ${m.page_num})">
                  <span class="page-num">p.${m.page_num}</span>
                  <span class="snippet">${m.snippet}</span>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }
      
      document.getElementById('modalBody').innerHTML = `
        <div>
          <img class="modal-thumb" src="/api/thumbnail/${id}" alt="" />
        </div>
        <div class="modal-details">
          <h2>${escapeHtml(asset.title || asset.filename)}</h2>
          
          <div class="detail-row">
            <span class="detail-label">Filename</span>
            <span class="detail-value">${escapeHtml(asset.filename)}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Author</span>
            <span class="detail-value">${escapeHtml(asset.author || '')}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Publisher</span>
            <span class="detail-value">${escapeHtml(asset.publisher || '')}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Game System</span>
            <span class="detail-value">${escapeHtml(asset.game_system || '')}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Pages</span>
            <span class="detail-value">${asset.page_count || ''}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">File Size</span>
            <span class="detail-value">${formatSize(asset.file_size)}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Path</span>
            <span class="detail-value breadcrumbs">${renderBreadcrumbs(asset.folder_path)}</span>
          </div>
          
          ${searchMatchesHtml}
          
          <div class="modal-actions">
            <button class="btn btn-primary" onclick="closeModal(); openToPage(${id}, 1)">
               Preview
            </button>
            <button class="btn btn-secondary" onclick="downloadAsset(${id}, '${asset.filename?.replace(/'/g, "\\'")}')">
               Download
            </button>
          </div>
          
          <div class="page-extract-section">
            <h4> Extract Pages</h4>
            <div class="page-extract-row">
              <input type="text" id="extractPages" placeholder="e.g., 1, 3, 5-10" class="page-input" />
              <button class="btn btn-secondary" onclick="extractPages(${id}, ${asset.page_count})">
                Extract & Download
              </button>
            </div>
            <div class="page-extract-hint">
              Enter page numbers (1-${asset.page_count || '?'}). Use commas for individual pages, dashes for ranges.
            </div>
          </div>
          
          <div class="bookmarks-section" id="bookmarksSection">
            <h4 onclick="toggleBookmarks(${id})" style="cursor:pointer">
               Table of Contents <span id="bookmarksToggle"></span>
            </h4>
            <div class="bookmarks-list" id="bookmarksList" style="display:none"></div>
          </div>
        </div>
      `;
      
      document.getElementById('modal').classList.add('active');
    }
    
    function closeModal() {
      const modal = document.getElementById('modal');
      if (modal) modal.classList.remove('active');
    }
    
    // Page Preview Modal State
    let previewAssetId = null;
    let previewCurrentPage = 1;
    let previewTotalPages = 1;
    let previewAssetTitle = '';
    let previewZoom = 100;  // Zoom percentage
    
    function updateZoomUI() {
      document.getElementById('zoomLevel').textContent = previewZoom + '%';
      const img = document.getElementById('previewImage');
      img.style.transform = `scale(${previewZoom / 100})`;
      img.style.transformOrigin = 'center center';
    }
    
    function zoomIn() {
      if (previewZoom < 300) {
        previewZoom = Math.min(300, previewZoom + 25);
        updateZoomUI();
      }
    }
    
    function zoomOut() {
      if (previewZoom > 25) {
        previewZoom = Math.max(25, previewZoom - 25);
        updateZoomUI();
      }
    }
    
    function zoomReset() {
      previewZoom = 100;
      updateZoomUI();
    }
    
    async function openToPage(assetId, pageNum) {
      // Open page preview modal instead of full PDF
      previewAssetId = assetId;
      previewCurrentPage = pageNum;
      
      // Reset zoom
      previewZoom = 100;
      updateZoomUI();
      
      // Get asset info for total pages and title
      const res = await fetch(`/api/assets/${assetId}`);
      const asset = await res.json();
      previewTotalPages = asset.page_count || 1;
      previewAssetTitle = asset.title || asset.filename;
      
      // Update UI
      document.getElementById('previewTitle').textContent = previewAssetTitle;
      document.getElementById('previewPageNum').textContent = pageNum;
      document.getElementById('previewTotalPages').textContent = previewTotalPages;
      
      // Update nav buttons
      updatePreviewNavButtons();
      
      // Load the page image
      loadPreviewPage(assetId, pageNum);
      
      // Show modal
      document.getElementById('pagePreview').classList.add('active');
      
      // Handle escape key
      document.addEventListener('keydown', handlePreviewKeydown);
    }
    
    function loadPreviewPage(assetId, pageNum) {
      const img = document.getElementById('previewImage');
      img.classList.add('loading');
      img.src = `/api/render/${assetId}/${pageNum}?zoom=2`;
      img.onload = () => img.classList.remove('loading');
    }
    
    function updatePreviewNavButtons() {
      document.getElementById('prevPageBtn').disabled = previewCurrentPage <= 1;
      document.getElementById('nextPageBtn').disabled = previewCurrentPage >= previewTotalPages;
    }
    
    function previewPrevPage() {
      if (previewCurrentPage > 1) {
        previewCurrentPage--;
        document.getElementById('previewPageNum').textContent = previewCurrentPage;
        loadPreviewPage(previewAssetId, previewCurrentPage);
        updatePreviewNavButtons();
      }
    }
    
    function previewNextPage() {
      if (previewCurrentPage < previewTotalPages) {
        previewCurrentPage++;
        document.getElementById('previewPageNum').textContent = previewCurrentPage;
        loadPreviewPage(previewAssetId, previewCurrentPage);
        updatePreviewNavButtons();
      }
    }
    
    function handlePreviewKeydown(e) {
      if (!document.getElementById('pagePreview').classList.contains('active')) return;
      
      if (e.key === 'Escape') {
        closePagePreview();
      } else if (e.key === 'ArrowLeft') {
        previewPrevPage();
      } else if (e.key === 'ArrowRight') {
        previewNextPage();
      } else if (e.key === '+' || e.key === '=') {
        zoomIn();
      } else if (e.key === '-' || e.key === '_') {
        zoomOut();
      } else if (e.key === '0') {
        zoomReset();
      }
    }
    
    function closePagePreview() {
      document.getElementById('pagePreview').classList.remove('active');
      document.removeEventListener('keydown', handlePreviewKeydown);
    }
    
    function downloadPreviewPages() {
      const rangeSelect = document.getElementById('pageRangeSelect');
      const range = rangeSelect.value;
      
      if (range === 'custom') {
        const customRange = prompt(
          `Enter page range (1-${previewTotalPages}):\nExamples: "5-10" or "1,3,5-8"`,
          `${previewCurrentPage}`
        );
        if (customRange) {
          window.location.href = `/api/extract-pages/${previewAssetId}?pages=${encodeURIComponent(customRange)}`;
        }
        return;
      }
      
      const offset = parseInt(range);
      const startPage = Math.max(1, previewCurrentPage - offset);
      const endPage = Math.min(previewTotalPages, previewCurrentPage + offset);
      
      let pages;
      if (startPage === endPage) {
        pages = `${startPage}`;
      } else {
        pages = `${startPage}-${endPage}`;
      }
      
      window.location.href = `/api/extract-pages/${previewAssetId}?pages=${encodeURIComponent(pages)}`;
    }
    
    function extractPages(assetId, maxPages) {
      const pagesInput = document.getElementById('extractPages');
      const pages = pagesInput.value.trim();
      
      if (!pages) {
        alert('Please enter page numbers to extract');
        return;
      }
      
      // Validate format
      if (!/^[\d,\s-]+$/.test(pages)) {
        alert('Invalid format. Use numbers, commas, and dashes only.\nExample: 1, 3, 5-10');
        return;
      }
      
      // Download extracted pages
      window.location.href = `/api/extract-pages/${assetId}?pages=${encodeURIComponent(pages)}`;
    }
    
    let bookmarksLoaded = false;
    
    async function toggleBookmarks(assetId) {
      const list = document.getElementById('bookmarksList');
      const toggle = document.getElementById('bookmarksToggle');
      
      if (list.style.display === 'none') {
        list.style.display = 'block';
        toggle.textContent = '';
        
        if (!bookmarksLoaded) {
          list.innerHTML = '<div class="bookmarks-empty">Loading...</div>';
          
          const res = await fetch(`/api/assets/${assetId}/bookmarks`);
          const bookmarks = await res.json();
          
          if (bookmarks.length === 0) {
            list.innerHTML = '<div class="bookmarks-empty">No table of contents available</div>';
          } else {
            list.innerHTML = bookmarks.map(b => `
              <div class="bookmark-item bookmark-level-${Math.min(b.level, 4)}" 
                   onclick="openToPage(${assetId}, ${b.page_num})">
                <span class="bookmark-title" title="${escapeHtml(b.title)}">${escapeHtml(b.title)}</span>
                <span class="bookmark-page">p.${b.page_num}</span>
              </div>
            `).join('');
          }
          bookmarksLoaded = true;
        }
      } else {
        list.style.display = 'none';
        toggle.textContent = '';
      }
    }
    
    function toggleView() {
      const grid = document.getElementById('assetGrid');
      const list = document.getElementById('assetList');
      const contentGrid = document.querySelector('.content-grid');
      const contentList = document.querySelector('.content-list');
      
      if (currentView === 'grid') {
        grid.classList.remove('hidden');
        list.classList.remove('active');
        if (contentGrid) contentGrid.classList.remove('hidden');
        if (contentList) contentList.classList.add('hidden');
      } else {
        grid.classList.add('hidden');
        list.classList.add('active');
        if (contentGrid) contentGrid.classList.add('hidden');
        if (contentList) contentList.classList.remove('hidden');
      }
    }
    
    function formatSize(bytes) {
      if (!bytes) return '';
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }
    
    function renderBreadcrumbs(folderPath) {
      if (!folderPath) return '';
      const parts = folderPath.split('/');
      const crumbs = parts.map((part, i) => {
        const fullPath = parts.slice(0, i + 1).join('/');
        // Use data attribute to avoid HTML escaping issues with & and quotes
        // Add oncontextmenu for right-click context menu
        return `<a href="#" class="breadcrumb-link" data-folder="${escapeHtml(fullPath)}" onclick="event.preventDefault(); event.stopPropagation(); navigateToFolder(this.dataset.folder)" oncontextmenu="showBreadcrumbContextMenu(event, this.dataset.folder)">${escapeHtml(part)}</a>`;
      });
      return crumbs.join(' <span class="breadcrumb-sep"></span> ');
    }
    
    function navigateToFolder(path) {
      console.log('navigateToFolder called with:', path, 'contentType:', contentType);
      closeModal();
      // Clear search so folder filter takes effect
      document.getElementById('searchInput').value = '';
      document.getElementById('contentResults').style.display = 'none';
      lastSearchQuery = '';
      
      // Use the right filter based on current mode
      if (contentType === '3d') {
        console.log('Calling filter3dFolder');
        filter3dFolder(path);
      } else {
        console.log('Calling filterFolder');
        filterFolder(path);
      }
    }
    
    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
      }[c]));
    }
    
    // ==================== SETTINGS ====================
    
    let browserTargetSetting = null;
    let browserTargetInput = null;
    let assetLocations = [];
    let hostPlatform = 'unknown';
    
    async function openSettings() {
      // Check platform and configure UI accordingly
      try {
        const healthRes = await fetch('/api/system/health');
        const health = await healthRes.json();
        hostPlatform = health.platform || 'unknown';
        
        // Hide SFTP option on macOS/Windows (requires sshfs which needs kernel extensions)
        const sftpOption = document.getElementById('optionSftp');
        const sftpHint = document.getElementById('sftpDisabledHint');
        if (hostPlatform === 'darwin' || hostPlatform === 'win32') {
          sftpOption.style.display = 'none';
          // Hint will show only if user somehow has SFTP selected (shouldn't happen)
        } else {
          sftpOption.style.display = '';
        }
        // Always hide hint initially - it will show in toggleLocationFields() if needed
        sftpHint.style.display = 'none';
      } catch (e) {
        console.error('Failed to check platform:', e);
      }
      
      document.getElementById('settingsModal').classList.add('active');
      
      // Load asset locations
      await loadAssetLocations();
      
      // Set default start date to today if empty
      const startDateInput = document.getElementById('newPolicyStartDate');
      if (startDateInput && !startDateInput.value) {
        startDateInput.value = new Date().toISOString().split('T')[0];
      }
      
      // Load volume status when opening settings
      refreshVolumeStatus();
    }
    
    // ==================== ASSET LOCATIONS ====================
    
    async function loadAssetLocations() {
      const container = document.getElementById('assetLocationsList');
      container.innerHTML = '<div class="location-empty">Loading...</div>';
      
      try {
        const response = await fetch('/api/asset-locations');
        const data = await response.json();
        assetLocations = data.locations || [];
        
        if (assetLocations.length === 0) {
          container.innerHTML = '<div class="location-empty">No asset locations configured. Click "Add Asset Location" to get started.</div>';
          return;
        }
        
        container.innerHTML = assetLocations.map(loc => renderLocationItem(loc)).join('');
      } catch (e) {
        container.innerHTML = '<div class="location-empty">Failed to load locations</div>';
        console.error('Error loading asset locations:', e);
      }
    }
    
    function renderLocationItem(loc) {
      const icon = loc.asset_type === 'documents' ? '' : '';
      const typeLabel = loc.asset_type === 'documents' ? 'Documents' : 'Models';
      const locTypeLabels = { local: 'Local', local_mount: 'Network Mount', remote_sftp: 'SFTP' };
      const disabledClass = loc.enabled ? '' : 'disabled';
      
      return `
        <div class="location-item ${disabledClass}" data-id="${loc.id}">
          <div class="location-icon">${icon}</div>
          <div class="location-info">
            <div class="location-name">${escapeHtml(loc.name)}</div>
            <div class="location-path" title="${escapeHtml(loc.path)}">${escapeHtml(loc.path)}</div>
            <div class="location-badges">
              <span class="location-badge ${loc.asset_type}">${typeLabel}</span>
              <span class="location-badge ${loc.location_type}">${locTypeLabels[loc.location_type] || loc.location_type}</span>
              ${!loc.enabled ? '<span class="location-badge" style="background:rgba(255,0,0,0.2);color:#ff6b6b;">Disabled</span>' : ''}
            </div>
          </div>
          <div class="location-actions">
            <button class="action-test" onclick="testAssetLocation('${loc.id}')" title="Test connection"> Test</button>
            <button class="action-index" onclick="indexLocation('${loc.id}', '${loc.asset_type}')" title="Index this location"> Index</button>
            ${loc.location_type === 'local_mount' ? `<button class="action-remount" onclick="remountLocation('${loc.id}', '${escapeHtml(loc.path)}')" title="Remount this volume"> Remount</button>` : ''}
            <div class="location-edit-wrapper">
              <button onclick="toggleLocationEditMenu(event, '${loc.id}')"> Edit</button>
              <div class="location-edit-menu" id="editMenu-${loc.id}">
                <button onclick="editLocationPath('${loc.id}')"> Change Path</button>
                <button onclick="toggleLocationEnabled('${loc.id}')">${loc.enabled ? ' Disable' : ' Enable'}</button>
                <div class="menu-divider"></div>
                <button onclick="forceIndexLocation('${loc.id}', '${escapeHtml(loc.path)}')"> Force Full Index</button>
                <button onclick="forceRegenThumbnails('${loc.id}', '${escapeHtml(loc.path)}')"> Force Regen Thumbnails</button>
                <button onclick="showLocationStatus('${loc.id}')"> Index Status</button>
                <div class="menu-divider"></div>
                <button class="danger" onclick="confirmDeleteLocation('${loc.id}', '${escapeHtml(loc.name)}')"> Delete</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Toggle edit menu
    function toggleLocationEditMenu(event, locId) {
      event.stopPropagation();
      const menu = document.getElementById('editMenu-' + locId);
      const wasOpen = menu.classList.contains('open');
      
      // Close all menus
      document.querySelectorAll('.location-edit-menu.open').forEach(m => m.classList.remove('open'));
      
      if (!wasOpen) {
        menu.classList.add('open');
        // Close on outside click
        setTimeout(() => {
          document.addEventListener('click', closeAllEditMenus, { once: true });
        }, 0);
      }
    }
    
    function closeAllEditMenus() {
      document.querySelectorAll('.location-edit-menu.open').forEach(m => m.classList.remove('open'));
    }
    
    // Index a specific location
    async function indexLocation(locId, assetType) {
      const type = assetType === 'documents' ? 'pdf' : '3d';
      
      // Find the location to get its path
      const loc = assetLocations.find(l => l.id === locId);
      if (!loc) {
        showToast('Location not found', 'error');
        return;
      }
      
      showToast(`Indexing ${loc.name}...`, 'info');
      
      try {
        const response = await fetch('/api/index', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type, path: loc.path })
        });
        const data = await response.json();
        
        if (response.ok) {
          if (data.status === 'suspended') {
            showToast(` ${data.message}`, 'warning');
          } else {
            showToast(' Indexing started!', 'success');
          }
        } else {
          showToast(data.error || 'Failed to start indexing', 'error');
        }
      } catch (e) {
        showToast('Error: ' + e.message, 'error');
      }
    }
    
    // Edit location path
    function editLocationPath(locId) {
      closeAllEditMenus();
      const loc = assetLocations.find(l => l.id === locId);
      if (!loc) return;
      
      const newPath = prompt('Enter new path:', loc.path);
      if (newPath && newPath !== loc.path) {
        updateLocationPath(locId, newPath);
      }
    }
    
    async function updateLocationPath(locId, newPath) {
      try {
        const response = await fetch(`/api/asset-locations/${locId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path: newPath })
        });
        
        if (response.ok) {
          showToast('Path updated!', 'success');
          await loadAssetLocations();
        } else {
          const data = await response.json();
          showToast(data.error || 'Failed to update', 'error');
        }
      } catch (e) {
        showToast('Error: ' + e.message, 'error');
      }
    }
    
    // Delete confirmation
    let pendingDeleteId = null;
    
    function confirmDeleteLocation(locId, locName) {
      closeAllEditMenus();
      pendingDeleteId = locId;
      document.getElementById('deleteLocName').textContent = locName;
      document.getElementById('deleteConfirmOverlay').classList.add('active');
    }
    
    function cancelDelete() {
      pendingDeleteId = null;
      document.getElementById('deleteConfirmOverlay').classList.remove('active');
    }
    
    async function executeDelete() {
      if (!pendingDeleteId) return;
      
      try {
        const response = await fetch(`/api/asset-locations/${pendingDeleteId}`, { method: 'DELETE' });
        
        if (response.ok) {
          showToast('Location deleted', 'success');
          await loadAssetLocations();
        } else {
          const data = await response.json();
          showToast(data.error || 'Failed to delete', 'error');
        }
      } catch (e) {
        showToast('Error: ' + e.message, 'error');
      }
      
      cancelDelete();
    }
    
    // Test location connectivity
    async function testAssetLocation(locId) {
      try {
        const response = await fetch(`/api/asset-locations/${locId}/test`, { method: 'POST' });
        const data = await response.json();
        showToast(data.success ? ' Connection successful!' : ` ${data.error || 'Connection failed'}`, data.success ? 'success' : 'error');
      } catch (e) {
        showToast('Test failed: ' + e.message, 'error');
      }
    }
    
    // Remount a network volume
    async function remountLocation(locId, path) {
      showToast(' Attempting to remount...', 'info');
      
      try {
        const response = await fetch(`/api/asset-locations/${locId}/remount`, { method: 'POST' });
        const data = await response.json();
        
        if (data.success) {
          showToast(' Volume remounted successfully!', 'success');
        } else {
          showToast(` Remount failed: ${data.error || 'Unknown error'}`, 'error');
        }
      } catch (e) {
        showToast('Remount failed: ' + e.message, 'error');
      }
    }
    
    function showAddLocationModal() {
      // Reset form
      document.getElementById('locName').value = '';
      document.getElementById('locAssetType').value = 'documents';
      document.getElementById('locType').value = 'local';
      document.getElementById('locPath').value = '';
      document.getElementById('locSshHost').value = '';
      document.getElementById('locEnabled').checked = true;
      document.getElementById('locValidationMsg').textContent = '';
      
      // Reset SSH auth state
      resetSshAuthState();
      
      toggleLocationFields();
      document.getElementById('addLocationModal').classList.add('active');
    }
    
    function closeAddLocationModal() {
      document.getElementById('addLocationModal').classList.remove('active');
    }
    
    // Track selected key path for location modal
    let locSelectedKeyPath = null;
    let locNewKeyPath = null;
    
    function toggleLocationFields() {
      const locType = document.getElementById('locType').value;
      const isRemote = locType === 'remote_sftp';
      
      document.getElementById('locSshHostRow').style.display = isRemote ? 'block' : 'none';
      document.getElementById('locSshKeyRow').style.display = isRemote ? 'block' : 'none';
      document.getElementById('locBrowseBtn').style.display = isRemote ? 'none' : 'inline-block';
      
      // Show SFTP warning only if SFTP selected on macOS/Windows
      const sftpHint = document.getElementById('sftpDisabledHint');
      if (isRemote && (hostPlatform === 'darwin' || hostPlatform === 'win32')) {
        sftpHint.style.display = 'block';
      } else {
        sftpHint.style.display = 'none';
      }
      
      // Reset SSH auth state
      if (isRemote) {
        resetSshAuthState();
        loadLocationSshKeys();
      }
      
      // Test connection visibility is controlled by auth method selection
      updateTestConnectionVisibility();
      
      // Update path placeholder
      const pathInput = document.getElementById('locPath');
      if (isRemote) {
        pathInput.placeholder = '/remote/path/to/assets';
      } else if (locType === 'local_mount') {
        pathInput.placeholder = '/Volumes/ShareName/path';
      } else {
        pathInput.placeholder = '/path/to/assets';
      }
    }
    
    function resetSshAuthState() {
      // Clear radio selections
      document.querySelectorAll('input[name="sshAuthMethod"]').forEach(r => r.checked = false);
      
      // Hide all panels
      document.getElementById('sshExistingPanel').style.display = 'none';
      document.getElementById('sshCreatePanel').style.display = 'none';
      document.getElementById('sshConfigPanel').style.display = 'none';
      document.getElementById('locKeyInfo').style.display = 'none';
      document.getElementById('locNewKeyInfo').style.display = 'none';
      document.getElementById('locCreateKeyStatus').style.display = 'block';
      
      // Reset state
      locSelectedKeyPath = null;
      locNewKeyPath = null;
      document.getElementById('locSshKeySelect').value = '';
      document.getElementById('locTestResult').textContent = '';
    }
    
    function onSshAuthMethodChange() {
      const method = document.querySelector('input[name="sshAuthMethod"]:checked')?.value;
      
      // Hide all panels
      document.getElementById('sshExistingPanel').style.display = 'none';
      document.getElementById('sshCreatePanel').style.display = 'none';
      document.getElementById('sshConfigPanel').style.display = 'none';
      
      // Show selected panel
      if (method === 'existing') {
        document.getElementById('sshExistingPanel').style.display = 'block';
      } else if (method === 'create') {
        document.getElementById('sshCreatePanel').style.display = 'block';
      } else if (method === 'config') {
        document.getElementById('sshConfigPanel').style.display = 'block';
      }
      
      updateTestConnectionVisibility();
    }
    
    function updateTestConnectionVisibility() {
      const locType = document.getElementById('locType').value;
      const method = document.querySelector('input[name="sshAuthMethod"]:checked')?.value;
      const isRemote = locType === 'remote_sftp';
      
      // Show test button if:
      // - Remote location AND
      // - (existing key selected OR new key created OR config selected)
      const hasValidConfig = isRemote && (
        (method === 'existing' && locSelectedKeyPath) ||
        (method === 'create' && locNewKeyPath) ||
        method === 'config'
      );
      
      document.getElementById('locTestConnectionRow').style.display = hasValidConfig ? 'flex' : 'none';
    }
    
    // Load SSH keys into the location dropdown
    async function loadLocationSshKeys() {
      const select = document.getElementById('locSshKeySelect');
      select.innerHTML = '<option value="">-- Select a key --</option>';
      
      try {
        const response = await fetch('/api/ssh/keys');
        const data = await response.json();
        
        if (data.keys && data.keys.length > 0) {
          data.keys.forEach(key => {
            const opt = document.createElement('option');
            opt.value = key.path;
            opt.textContent = `${key.name} (${key.type})`;
            select.appendChild(opt);
          });
        }
      } catch (e) {
        console.error('Error loading SSH keys:', e);
      }
    }
    
    // When a key is selected from dropdown
    async function onLocKeySelected() {
      const select = document.getElementById('locSshKeySelect');
      const keyPath = select.value;
      
      if (!keyPath) {
        locSelectedKeyPath = null;
        document.getElementById('locKeyInfo').style.display = 'none';
        updateTestConnectionVisibility();
        return;
      }
      
      locSelectedKeyPath = keyPath;
      
      // Load and display public key
      try {
        const response = await fetch(`/api/ssh/key/public?path=${encodeURIComponent(keyPath)}`);
        if (response.ok) {
          const data = await response.json();
          document.getElementById('locPublicKeyDisplay').textContent = data.public_key || 'Unable to load public key';
        } else {
          document.getElementById('locPublicKeyDisplay').textContent = 'Public key file: ' + keyPath + '.pub';
        }
      } catch (e) {
        document.getElementById('locPublicKeyDisplay').textContent = 'Public key file: ' + keyPath + '.pub';
      }
      
      document.getElementById('locKeyInfo').style.display = 'block';
      updateTestConnectionVisibility();
    }
    
    function copyLocPublicKey() {
      const text = document.getElementById('locPublicKeyDisplay').textContent;
      navigator.clipboard.writeText(text).then(() => {
        showToast('Public key copied!', 'success');
      }).catch(() => {
        showToast('Failed to copy', 'error');
      });
    }
    
    function copyLocNewPublicKey() {
      const text = document.getElementById('locNewPublicKeyDisplay').textContent;
      navigator.clipboard.writeText(text).then(() => {
        showToast('Public key copied!', 'success');
      }).catch(() => {
        showToast('Failed to copy', 'error');
      });
    }
    
    // Create new SSH key for location
    async function createNewKeyForLocation() {
      const statusEl = document.getElementById('locCreateKeyStatus');
      statusEl.innerHTML = '<p style="color: var(--text-secondary);"> Generating key...</p>';
      
      try {
        const response = await fetch('/api/ssh/key', { method: 'POST' });
        const data = await response.json();
        
        if (data.success || data.exists) {
          locNewKeyPath = data.key_path;
          
          // Show the key info
          document.getElementById('locNewPublicKeyDisplay').textContent = data.public_key || 'Key generated at ' + data.key_path;
          document.getElementById('locCreateKeyStatus').style.display = 'none';
          document.getElementById('locNewKeyInfo').style.display = 'block';
          
          // Also refresh the existing keys dropdown
          await loadLocationSshKeys();
          
          showToast('SSH key ready!', 'success');
          updateTestConnectionVisibility();
        } else {
          statusEl.innerHTML = `
            <button type="button" class="btn btn-primary" onclick="createNewKeyForLocation()"> Generate New SSH Key</button>
            <p style="font-size: 0.85rem; color: #fa5252; margin-top: 8px;"> ${data.error || 'Failed to generate key'}</p>
          `;
        }
      } catch (e) {
        statusEl.innerHTML = `
          <button type="button" class="btn btn-primary" onclick="createNewKeyForLocation()"> Generate New SSH Key</button>
          <p style="font-size: 0.85rem; color: #fa5252; margin-top: 8px;"> Error: ${e.message}</p>
        `;
      }
    }
    
    // Get the currently selected SSH key path for saving
    function getSelectedSshKeyPath() {
      const method = document.querySelector('input[name="sshAuthMethod"]:checked')?.value;
      
      if (method === 'existing') {
        return locSelectedKeyPath || '';
      } else if (method === 'create') {
        return locNewKeyPath || '';
      }
      // For 'config' method, return empty - SSH will use system config
      return '';
    }
    
    // Test location connection
    async function testLocationConnection() {
      const resultEl = document.getElementById('locTestResult');
      const btn = document.getElementById('locTestConnBtn');
      
      const host = document.getElementById('locSshHost').value.trim();
      const keyPath = getSelectedSshKeyPath();  // Uses auth method selection
      const remotePath = document.getElementById('locPath').value.trim();
      
      if (!host) {
        resultEl.className = 'test-result error';
        resultEl.textContent = ' SSH host required';
        return;
      }
      
      btn.disabled = true;
      resultEl.className = 'test-result loading';
      resultEl.textContent = ' Testing...';
      
      try {
        const response = await fetch('/api/ssh/test', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ host, key_path: keyPath || null })
        });
        
        const data = await response.json();
        
        if (data.success) {
          resultEl.className = 'test-result success';
          resultEl.textContent = ' Connection successful!';
        } else {
          resultEl.className = 'test-result error';
          resultEl.textContent = ' ' + (data.error || 'Connection failed');
        }
      } catch (e) {
        resultEl.className = 'test-result error';
        resultEl.textContent = ' ' + e.message;
      } finally {
        btn.disabled = false;
      }
    }
    
    function browseLocationPath() {
      dirBrowserTargetInput = document.getElementById('locPath');
      openDirBrowser(dirBrowserTargetInput.value || '');
    }
    
    async function saveNewLocation() {
      const msgEl = document.getElementById('locValidationMsg');
      msgEl.textContent = '';
      
      const locationData = {
        name: document.getElementById('locName').value.trim(),
        asset_type: document.getElementById('locAssetType').value,
        location_type: document.getElementById('locType').value,
        path: document.getElementById('locPath').value.trim(),
        ssh_host: document.getElementById('locSshHost').value.trim(),
        ssh_key_path: getSelectedSshKeyPath(),  // Uses new auth method selection
        enabled: document.getElementById('locEnabled').checked
      };
      
      // Validation
      if (!locationData.name) {
        msgEl.textContent = ' Name is required';
        msgEl.style.color = '#ff6b6b';
        return;
      }
      if (!locationData.path) {
        msgEl.textContent = ' Path is required';
        msgEl.style.color = '#ff6b6b';
        return;
      }
      
      const isRemote = locationData.location_type === 'remote_sftp';
      if (isRemote && !locationData.ssh_host) {
        msgEl.textContent = ' SSH host is required for remote locations';
        msgEl.style.color = '#ff6b6b';
        return;
      }
      
      msgEl.textContent = ' Saving...';
      msgEl.style.color = 'var(--text-secondary)';
      
      try {
        const response = await fetch('/api/asset-locations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(locationData)
        });
        
        const result = await response.json();
        
        if (response.ok && result.success) {
          showToast('Location added', 'success');
          closeAddLocationModal();
          await loadAssetLocations();
        } else {
          msgEl.textContent = ' ' + (result.error || 'Failed to add location');
          msgEl.style.color = '#ff6b6b';
        }
      } catch (e) {
        msgEl.textContent = ' ' + e.message;
        msgEl.style.color = '#ff6b6b';
      }
    }
    
    async function testAssetLocation(locationId) {
      showToast('Testing connection...', 'info');
      
      try {
        const response = await fetch(`/api/asset-locations/${locationId}/test`, { method: 'POST' });
        const result = await response.json();
        
        if (result.success) {
          const msg = result.file_count !== undefined 
            ? ` ${result.message} (${result.file_count} files)`
            : ` ${result.message}`;
          showToast(msg, 'success');
        } else {
          showToast(' ' + (result.error || 'Test failed'), 'error');
        }
      } catch (e) {
        showToast(' ' + e.message, 'error');
      }
    }
    
    async function toggleLocationEnabled(locationId) {
      const loc = assetLocations.find(l => l.id === locationId);
      if (!loc) return;
      
      try {
        const response = await fetch(`/api/asset-locations/${locationId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ enabled: !loc.enabled })
        });
        
        if (response.ok) {
          showToast(loc.enabled ? 'Location disabled' : 'Location enabled', 'success');
          await loadAssetLocations();
        }
      } catch (e) {
        showToast('Failed to update', 'error');
      }
    }
    
    async function deleteAssetLocation(locationId) {
      const loc = assetLocations.find(l => l.id === locationId);
      if (!loc) return;
      
      if (!confirm(`Delete location "${loc.name}"?`)) return;
      
      try {
        const response = await fetch(`/api/asset-locations/${locationId}`, { method: 'DELETE' });
        
        if (response.ok) {
          showToast('Location deleted', 'success');
          await loadAssetLocations();
        } else {
          showToast('Failed to delete', 'error');
        }
      } catch (e) {
        showToast('Failed to delete', 'error');
      }
    }
    
    async function refreshVolumeStatus() {
      // Check volume status for index button states
      try {
        const res = await fetch('/api/system/volume-status');
        const data = await res.json();
        updateIndexButtonStates(data);
      } catch (e) {
        console.error('Failed to check volume status:', e);
      }
    }
    
    function updateIndexButtonStates(volumeStatus) {
      // Store status globally
      window.volumeStatus = volumeStatus;
      
      // Update PDF index button
      if (volumeStatus.volumes.pdfs && !volumeStatus.volumes.pdfs.available) {
        updateIndexButtonSuspended('pdf', true, volumeStatus.volumes.pdfs.reason);
      } else {
        updateIndexButtonSuspended('pdf', false);
      }
      
      // Update 3D index button
      if (volumeStatus.volumes.models && !volumeStatus.volumes.models.available) {
        updateIndexButtonSuspended('3d', true, volumeStatus.volumes.models.reason);
      } else {
        updateIndexButtonSuspended('3d', false);
      }
    }
    
    function updateIndexButtonSuspended(type, isSuspended, reason = '') {
      // Find the index button for this type
      const buttonSelector = {
        'pdf': 'button[onclick="indexNow(\'pdf\')"]',
        '3d': 'button[onclick="indexNow(\'3d\')"]'
      }[type];
      
      const btn = document.querySelector(buttonSelector);
      if (!btn) return;
      
      const originalText = { 'pdf': ' Scan Documents', '3d': ' Scan 3D Models' }[type];
      
      if (isSuspended) {
        btn.classList.add('suspended');
        btn.innerHTML = `${originalText} <span class="suspended-badge"></span>`;
        btn.title = `SUSPENDED: ${reason || 'Volume unavailable'}`;
      } else {
        btn.classList.remove('suspended');
        btn.innerHTML = originalText;
        btn.title = `Scan all ${type === 'pdf' ? 'document' : '3D model'} locations`;
      }
    }
    
    // Toast notification system
    function showToast(message, type = 'info') {
      // Create toast container if it doesn't exist
      let container = document.getElementById('toastContainer');
      if (!container) {
        container = document.createElement('div');
        container.id = 'toastContainer';
        container.className = 'toast-container';
        document.body.appendChild(container);
      }
      
      // Create toast element
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      
      const icons = { 'success': '', 'warning': '', 'error': '', 'info': '' };
      toast.innerHTML = `<span class="toast-icon">${icons[type] || icons.info}</span><span class="toast-message">${message}</span>`;
      
      container.appendChild(toast);
      
      // Trigger animation
      setTimeout(() => toast.classList.add('show'), 10);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
      }, 5000);
    }
    
    function closeSettings() {
      document.getElementById('settingsModal').classList.remove('active');
    }
    
    async function saveSettings() {
      // Settings are now saved per-feature (Asset Locations, Backup Policies, etc.)
      closeSettings();
      showToast('Settings saved!', 'success');
    }
    
    async function browseDirectory(settingKey, inputId) {
      browserTargetSetting = settingKey;
      browserTargetInput = inputId;
      await loadBrowserDirectory('/Volumes');
      document.getElementById('browserModal').classList.add('active');
    }
    
    async function loadBrowserDirectory(path) {
      try {
        const res = await fetch(`/api/browse-directory?path=${encodeURIComponent(path)}`);
        const data = await res.json();
        
        document.getElementById('browserPath').textContent = data.current;
        
        let html = '';
        if (data.parent) {
          html += `<div class="browser-item parent" onclick="loadBrowserDirectory('${data.parent}')">
             ..
          </div>`;
        }
        
        html += data.entries.map(e => `
          <div class="browser-item" onclick="loadBrowserDirectory('${e.path}')">
             ${e.name}
          </div>
        `).join('');
        
        document.getElementById('browserList').innerHTML = html || '<div style="padding:20px;color:#888">No subdirectories</div>';
      } catch (e) {
        console.error('Failed to browse:', e);
      }
    }
    
    function closeBrowser() {
      document.getElementById('browserModal').classList.remove('active');
      browserSelectCallback = null;  // Clear callback on close
    }
    
    let browserSelectCallback = null;  // Optional callback for browser selection
    
    function selectBrowserPath() {
      const path = document.getElementById('browserPath').textContent;
      
      // If there's a callback, use it
      if (browserSelectCallback) {
        const callback = browserSelectCallback;
        browserSelectCallback = null;
        closeBrowser();
        callback(path);
        return;
      }
      
      // Default behavior: fill input
      if (browserTargetInput) {
        document.getElementById(browserTargetInput).value = path;
      }
      closeBrowser();
    }
    
    async function indexNow(type) {
      const statusId = type + 'IndexStatus';
      const statusEl = document.getElementById(statusId);
      
      let path;
      if (type === 'pdf') {
        // Get paths from document asset locations
        const docLocations = assetLocations.filter(l => l.asset_type === 'documents' && l.enabled);
        if (docLocations.length === 0) {
          statusEl.className = 'index-status error';
          statusEl.textContent = ' No document locations configured';
          return;
        }
        path = docLocations.map(l => l.path).join(',');
      } else if (type === '3d') {
        // Get paths from 3D model asset locations
        const modelLocations = assetLocations.filter(l => l.asset_type === 'models' && l.enabled);
        if (modelLocations.length === 0) {
          statusEl.className = 'index-status error';
          statusEl.textContent = ' No 3D model locations configured';
          return;
        }
        path = modelLocations.map(l => l.path).join(',');
      }
      
      if (!path) {
        statusEl.className = 'index-status error';
        statusEl.textContent = ' No path configured';
        return;
      }
      
      statusEl.className = 'index-status active';
      statusEl.textContent = ' Indexing started... This may take a while.';
      
      try {
        const res = await fetch('/api/index', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type, path })
        });
        
        const data = await res.json();
        
        if (res.ok) {
          // Check for suspended status
          if (data.status === 'suspended') {
            statusEl.className = 'index-status suspended';
            statusEl.textContent = ` ${data.message}`;
            // Update button to show suspended state
            updateIndexButtonSuspended(type, true, data.message);
            // Show toast notification
            showToast(data.message, 'warning');
          } else if (data.status === 'started') {
            statusEl.className = 'index-status success';
            statusEl.textContent = ` ${data.message}`;
            // Clear any suspended state
            updateIndexButtonSuspended(type, false);
            // Refresh stats
            loadStats();
          } else {
            statusEl.className = 'index-status success';
            statusEl.textContent = ` ${data.message}`;
            loadStats();
          }
        } else {
          statusEl.className = 'index-status error';
          statusEl.textContent = ` ${data.error}`;
        }
      } catch (e) {
        statusEl.className = 'index-status error';
        statusEl.textContent = ` Error: ${e.message}`;
      }
    }
    
    // ==================== 3D THUMBNAIL RENDERING ====================
    
    let thumbnailPollInterval = null;
    
    async function renderAllThumbnails() {
      const statusEl = document.getElementById('renderThumbStatus');
      const btn = document.getElementById('renderThumbBtn');
      
      btn.disabled = true;
      statusEl.className = 'index-status active';
      statusEl.textContent = ' Rendering thumbnails... This may take several minutes.';
      
      try {
        const res = await fetch('/api/models/render-thumbnails', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        
        const data = await res.json();
        
        if (res.ok) {
          statusEl.className = 'index-status success';
          statusEl.textContent = ` ${data.message} (${data.models_queued} queued, ${data.already_cached} cached)`;
          
          // Start polling to refresh grid as thumbnails complete
          if (data.models_queued > 0) {
            startThumbnailPolling();
          }
          
          loadStats();
        } else {
          statusEl.className = 'index-status error';
          statusEl.textContent = ` ${data.error}`;
        }
      } catch (e) {
        statusEl.className = 'index-status error';
        statusEl.textContent = ` Error: ${e.message}`;
      } finally {
        btn.disabled = false;
      }
    }
    
    function startThumbnailPolling() {
      if (thumbnailPollInterval) return; // Already polling
      
      console.log('Starting thumbnail polling...');
      
      thumbnailPollInterval = setInterval(async () => {
        // Refresh all grid thumbnails with cache-busting
        const timestamp = Date.now();
        document.querySelectorAll('img[data-model-id]').forEach(img => {
          const modelId = img.getAttribute('data-model-id');
          img.src = `/api/models/${modelId}/preview?t=${timestamp}`;
        });
        
        // Check if rendering is complete
        try {
          const res = await fetch('/api/models/render-thumbnails/status');
          const data = await res.json();
          
          if (!data.active) {
            console.log('Thumbnail rendering complete, stopping poll');
            stopThumbnailPolling();
            loadStats();
          }
        } catch (e) {
          console.error('Poll error:', e);
        }
      }, 3000); // Poll every 3 seconds
    }
    
    function stopThumbnailPolling() {
      if (thumbnailPollInterval) {
        clearInterval(thumbnailPollInterval);
        thumbnailPollInterval = null;
        console.log('Stopped thumbnail polling');
      }
    }
    
    async function checkThumbnailRenderStatus() {
      try {
        const res = await fetch('/api/models/render-thumbnails/status');
        const data = await res.json();
        
        if (data.active) {
          console.log('Thumbnail rendering already in progress, starting polling');
          startThumbnailPolling();
        }
      } catch (e) {
        console.error('Error checking thumbnail render status:', e);
      }
    }
    
    async function renderThumbStats(btn) {
      const statusEl = document.getElementById('renderThumbStatus');
      if (btn) btn.disabled = true;
      
      statusEl.className = 'index-status active';
      statusEl.textContent = ' Checking thumbnail status...';
      
      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 15000); // 15s timeout
        
        const res = await fetch('/api/models/thumbnail-stats', { signal: controller.signal });
        clearTimeout(timeout);
        const data = await res.json();
        
        if (res.ok) {
          const percent = data.percent.toFixed(1);
          statusEl.className = 'index-status info';
          statusEl.textContent = ` ${data.cached.toLocaleString()} / ${data.total.toLocaleString()} cached (${percent}%)  ${data.missing.toLocaleString()} remaining`;
        } else {
          statusEl.className = 'index-status error';
          statusEl.textContent = ` ${data.error}`;
        }
      } catch (e) {
        statusEl.className = 'index-status error';
        if (e.name === 'AbortError') {
          statusEl.textContent = ' Server busy, still checking... (try again in a moment)';
        } else {
          statusEl.textContent = ` Error: ${e.message}`;
        }
      } finally {
        if (btn) btn.disabled = false;
      }
    }
    
    // ==================== BACKUP FUNCTIONALITY ====================
    
    async function createBackup() {
      const statusEl = document.getElementById('backupStatus');
      statusEl.className = 'index-status active';
      statusEl.textContent = ' Creating backup...';
      
      try {
        const res = await fetch('/api/backup', { method: 'POST' });
        const data = await res.json();
        
        if (data.success) {
          statusEl.className = 'index-status success';
          statusEl.textContent = ` ${data.message} (${data.size_mb} MB)`;
        } else {
          statusEl.className = 'index-status error';
          statusEl.textContent = ` ${data.error}`;
        }
      } catch (e) {
        statusEl.className = 'index-status error';
        statusEl.textContent = ` Error: ${e.message}`;
      }
    }
    
    async function showBackups() {
      const listEl = document.getElementById('backupList');
      const statusEl = document.getElementById('backupStatus');
      
      if (listEl.style.display === 'block') {
        listEl.style.display = 'none';
        return;
      }
      
      statusEl.className = 'index-status active';
      statusEl.textContent = ' Loading backups...';
      
      try {
        const res = await fetch('/api/backups');
        const data = await res.json();
        
        statusEl.className = '';
        statusEl.textContent = '';
        
        if (data.backups.length === 0) {
          listEl.innerHTML = '<div style="color:var(--text-secondary);padding:8px;">No backups found</div>';
        } else {
          listEl.innerHTML = `
            <div style="font-size:0.85rem; color:var(--text-secondary); margin-bottom:8px;">
              Available backups (click to restore):
            </div>
            ${data.backups.map(b => `
              <div style="display:flex; justify-content:space-between; align-items:center; padding:8px; background:var(--bg-card); border-radius:6px; margin-bottom:4px; cursor:pointer;"
                   onclick="restoreBackup('${b.filename}')"
                   title="Click to restore this backup">
                <span> ${b.filename}</span>
                <span style="color:var(--text-secondary); font-size:0.85rem;">${b.size_mb} MB</span>
              </div>
            `).join('')}
          `;
        }
        listEl.style.display = 'block';
      } catch (e) {
        statusEl.className = 'index-status error';
        statusEl.textContent = ` Error: ${e.message}`;
      }
    }
    
    async function restoreBackup(filename) {
      if (!confirm(`Restore database from ${filename}?\n\nThis will replace your current database. A backup of the current state will be created first.`)) {
        return;
      }
      
      const statusEl = document.getElementById('backupStatus');
      statusEl.className = 'index-status active';
      statusEl.textContent = ' Restoring backup...';
      
      try {
        const res = await fetch('/api/backup/restore', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filename })
        });
        const data = await res.json();
        
        if (data.success) {
          statusEl.className = 'index-status success';
          statusEl.textContent = ` ${data.message}`;
          // Refresh page after 2 seconds
          setTimeout(() => location.reload(), 2000);
        } else {
          statusEl.className = 'index-status error';
          statusEl.textContent = ` ${data.error}`;
        }
      } catch (e) {
        statusEl.className = 'index-status error';
        statusEl.textContent = ` Error: ${e.message}`;
      }
    }
    
    // ==================== UPLOAD FUNCTIONALITY ====================
    
    let uploadFiles = [];
    let uploadCurrentPath = '';
    let uploadContentType = 'pdf';
    
    function openUpload() {
      uploadContentType = contentType;  // Use current content type from main UI
      uploadFiles = [];
      
      // Update UI for content type
      const icon = document.getElementById('uploadIcon');
      const label = document.getElementById('uploadTypeLabel');
      const hint = document.getElementById('uploadHint');
      
      if (uploadContentType === '3d') {
        icon.textContent = '';
        label.textContent = '3D Models';
        hint.textContent = 'Accepted: .stl, .obj, .3mf, .glb, .gltf, .zip, .rar, .7z';
        document.getElementById('uploadFileInput').accept = '.stl,.obj,.3mf,.glb,.gltf,.zip,.rar,.7z';
      } else {
        icon.textContent = '';
        label.textContent = 'PDFs';
        hint.textContent = 'Accepted: .pdf';
        document.getElementById('uploadFileInput').accept = '.pdf';
      }
      
      // Reset file list
      document.getElementById('uploadFileList').innerHTML = '';
      document.getElementById('uploadFileCount').textContent = 'No files selected';
      document.getElementById('uploadSubmitBtn').disabled = true;
      document.getElementById('uploadProgress').classList.remove('active');
      document.getElementById('newFolderName').value = '';
      
      // Load initial folder
      loadUploadFolders();
      
      document.getElementById('uploadModal').classList.add('active');
    }
    
    function closeUpload() {
      document.getElementById('uploadModal').classList.remove('active');
      uploadFiles = [];
    }
    
    async function loadUploadFolders(path = null) {
      try {
        let url = `/api/upload/browse?type=${uploadContentType}`;
        if (path) url += `&path=${encodeURIComponent(path)}`;
        
        const res = await fetch(url);
        const data = await res.json();
        
        if (data.error) {
          alert('Error: ' + data.error);
          return;
        }
        
        uploadCurrentPath = data.current;
        document.getElementById('uploadCurrentPath').textContent = data.current;
        
        let html = '';
        
        // Parent folder link (if not at root)
        if (data.parent) {
          html += `
            <div class="upload-folder-item parent" onclick="loadUploadFolders('${escapeHtml(data.parent)}')">
               ..
            </div>
          `;
        }
        
        // Subfolders
        data.entries.forEach(entry => {
          html += `
            <div class="upload-folder-item" onclick="loadUploadFolders('${escapeHtml(entry.path)}')">
               ${escapeHtml(entry.name)}
            </div>
          `;
        });
        
        if (!data.parent && data.entries.length === 0) {
          html = '<div style="padding:20px;color:var(--text-secondary);text-align:center">No subfolders</div>';
        }
        
        document.getElementById('uploadFolderList').innerHTML = html;
      } catch (e) {
        console.error('Failed to load folders:', e);
        document.getElementById('uploadFolderList').innerHTML = 
          '<div style="padding:20px;color:#e74c3c;text-align:center">Failed to load folders</div>';
      }
    }
    
    async function createUploadFolder() {
      const nameInput = document.getElementById('newFolderName');
      const name = nameInput.value.trim();
      
      if (!name) {
        alert('Please enter a folder name');
        return;
      }
      
      try {
        const res = await fetch('/api/upload/mkdir', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            parent: uploadCurrentPath,
            name: name,
            type: uploadContentType
          })
        });
        
        const data = await res.json();
        
        if (data.error) {
          alert('Error: ' + data.error);
          return;
        }
        
        nameInput.value = '';
        // Navigate to the new folder
        loadUploadFolders(data.path);
      } catch (e) {
        alert('Failed to create folder: ' + e.message);
      }
    }
    
    function handleFileSelect(event) {
      const files = Array.from(event.target.files);
      addUploadFiles(files);
    }
    
    function addUploadFiles(files) {
      // Filter by content type
      const allowedExts = uploadContentType === '3d' 
        ? ['.stl', '.obj', '.3mf', '.glb', '.gltf', '.zip', '.rar', '.7z']
        : ['.pdf'];
      
      files.forEach(file => {
        const ext = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
        if (allowedExts.includes(ext)) {
          // Check if already added
          if (!uploadFiles.some(f => f.name === file.name && f.size === file.size)) {
            uploadFiles.push(file);
          }
        }
      });
      
      renderUploadFiles();
    }
    
    function removeUploadFile(index) {
      uploadFiles.splice(index, 1);
      renderUploadFiles();
    }
    
    function renderUploadFiles() {
      const list = document.getElementById('uploadFileList');
      const count = document.getElementById('uploadFileCount');
      const btn = document.getElementById('uploadSubmitBtn');
      
      if (uploadFiles.length === 0) {
        list.innerHTML = '';
        count.textContent = 'No files selected';
        btn.disabled = true;
        return;
      }
      
      const totalSize = uploadFiles.reduce((sum, f) => sum + f.size, 0);
      count.textContent = `${uploadFiles.length} file(s)  ${formatSize(totalSize)}`;
      btn.disabled = false;
      
      list.innerHTML = uploadFiles.map((file, i) => `
        <div class="upload-file-item">
          <span class="name" title="${escapeHtml(file.name)}">${escapeHtml(file.name)}</span>
          <span class="size">${formatSize(file.size)}</span>
          <button class="remove" onclick="removeUploadFile(${i})" title="Remove"></button>
        </div>
      `).join('');
    }
    
    async function submitUpload() {
      if (uploadFiles.length === 0) return;
      
      if (!uploadCurrentPath) {
        alert('Error: No destination folder selected');
        return;
      }
      
      const btn = document.getElementById('uploadSubmitBtn');
      const progress = document.getElementById('uploadProgress');
      const progressFill = document.getElementById('uploadProgressFill');
      const progressText = document.getElementById('uploadProgressText');
      
      btn.disabled = true;
      btn.textContent = ' Uploading...';
      progress.classList.add('active');
      progressFill.style.width = '0%';
      progressText.textContent = 'Starting upload...';
      
      console.log('Preparing upload to:', uploadCurrentPath, 'type:', uploadContentType);
      
      const formData = new FormData();
      formData.append('destination', uploadCurrentPath);
      formData.append('type', uploadContentType);
      uploadFiles.forEach(file => formData.append('files', file));
      
      console.log('FormData prepared, total files:', uploadFiles.length);
      
      try {
        const xhr = new XMLHttpRequest();
        
        console.log('Upload starting:', uploadFiles.length, 'files to', uploadCurrentPath);
        
        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const pct = Math.round((e.loaded / e.total) * 100);
            progressFill.style.width = pct + '%';
            progressText.textContent = `Uploading... ${pct}%`;
            console.log('Upload progress:', pct + '%');
          }
        });
        
        xhr.addEventListener('readystatechange', () => {
          console.log('XHR state:', xhr.readyState, 'status:', xhr.status);
        });
        
        xhr.addEventListener('load', () => {
          console.log('XHR load event, status:', xhr.status, 'response:', xhr.responseText);
          if (xhr.status === 200) {
            const data = JSON.parse(xhr.responseText);
            progressFill.style.width = '100%';
            progressText.textContent = data.message;
            
            // Show success for 2 seconds, then close and refresh
            setTimeout(() => {
              closeUpload();
              // Clear any filters that might have been set
              currentFolder = null;
              currentPublisher = null;
              currentCollection = null;
              // Refresh everything properly
              if (uploadContentType === '3d') {
                load3dFolders();
                load3dCollections();
                load3dModels();
              } else {
                loadFolders();
                loadPublishers();
                loadAssets();
              }
              loadStats();
            }, 2000);
          } else {
            const data = JSON.parse(xhr.responseText);
            progressText.textContent = 'Error: ' + (data.error || 'Upload failed');
            progressFill.style.background = '#e74c3c';
            btn.disabled = false;
            btn.textContent = ' Upload';
          }
        });
        
        xhr.addEventListener('error', () => {
          progressText.textContent = 'Error: Upload failed';
          progressFill.style.background = '#e74c3c';
          btn.disabled = false;
          btn.textContent = ' Upload';
        });
        
        xhr.addEventListener('timeout', () => {
          progressText.textContent = 'Upload timed out (slow storage - file may still be processing)';
          progressFill.style.background = '#f39c12';
          btn.disabled = false;
          btn.textContent = ' Upload';
        });
        
        xhr.open('POST', '/api/upload');
        xhr.timeout = 300000;  // 5 minute timeout for slow storage
        xhr.send(formData);
      } catch (e) {
        progressText.textContent = 'Error: ' + e.message;
        btn.disabled = false;
        btn.textContent = ' Upload';
      }
    }
    
    async function triggerReindex(path) {
      // Optionally trigger indexing for the uploaded folder
      try {
        await fetch('/api/index', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            type: uploadContentType,
            path: path
          })
        });
        console.log('Reindex triggered for:', path);
      } catch (e) {
        console.log('Reindex request failed (may not be implemented):', e);
      }
    }
    
    // Drag and drop support for upload dropzone
    (function() {
      const dropzone = document.getElementById('uploadDropzone');
      if (!dropzone) return;
      
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(event => {
        dropzone.addEventListener(event, (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
      });
      
      ['dragenter', 'dragover'].forEach(event => {
        dropzone.addEventListener(event, () => {
          dropzone.classList.add('dragover');
        });
      });
      
      ['dragleave', 'drop'].forEach(event => {
        dropzone.addEventListener(event, () => {
          dropzone.classList.remove('dragover');
        });
      });
      
      dropzone.addEventListener('drop', (e) => {
        const files = Array.from(e.dataTransfer.files);
        addUploadFiles(files);
      });
    })();
    
    // ==================== END UPLOAD ====================

    // Resize handle functionality
    // ==========================================================================
    // DOWNLOAD ERROR HANDLING
    // ==========================================================================
    
    /**
     * Handle download with availability check.
     * Shows appropriate error if volume is offline or file is missing.
     */
    async function handleDownload(url, filename) {
      try {
        const response = await fetch(url);
        
        if (response.ok) {
          // Success - trigger actual download
          const blob = await response.blob();
          const downloadUrl = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = downloadUrl;
          a.download = filename || 'download';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(downloadUrl);
          return;
        }
        
        // Error response - parse and display
        const data = await response.json();
        
        if (response.status === 503 && data.error === 'volume_unavailable') {
          // Volume offline - show prominent warning
          showDownloadError({
            title: ' Storage Volume Offline',
            message: data.message || 'The storage volume containing this file is currently unavailable.',
            details: `Volume: ${data.volume || 'Unknown'}`,
            type: 'warning',
            suggestion: 'Check that the external drive or network share is connected.'
          });
        } else if (response.status === 404) {
          // File not found
          showDownloadError({
            title: ' File Not Found',
            message: data.message || 'The file could not be found on disk.',
            details: data.file_path ? `Path: ${data.file_path}` : '',
            type: 'error',
            suggestion: 'The file may have been moved, renamed, or deleted. Try re-indexing.'
          });
        } else {
          // Generic error
          showDownloadError({
            title: ' Download Failed',
            message: data.message || data.error || 'An unknown error occurred.',
            type: 'error'
          });
        }
      } catch (e) {
        showToast(`Download error: ${e.message}`, 'error');
      }
    }
    
    /**
     * Show download error modal with details.
     */
    function showDownloadError(opts) {
      const { title, message, details, type, suggestion } = opts;
      
      const modalHtml = `
        <div id="downloadErrorModal" class="modal-overlay" onclick="closeDownloadErrorModal(event)">
          <div class="modal-content download-error-modal">
            <div class="download-error-header ${type || 'error'}">
              <h3>${title}</h3>
            </div>
            <div class="download-error-body">
              <p>${message}</p>
              ${details ? `<p class="download-error-details">${details}</p>` : ''}
              ${suggestion ? `<p class="download-error-suggestion"> ${suggestion}</p>` : ''}
            </div>
            <div class="download-error-actions">
              <button class="btn btn-secondary" onclick="closeDownloadErrorModal()">Close</button>
              <button class="btn btn-primary" onclick="closeDownloadErrorModal(); openSettings()">Check Volumes</button>
            </div>
          </div>
        </div>
      `;
      
      // Remove any existing modal
      const existing = document.getElementById('downloadErrorModal');
      if (existing) existing.remove();
      
      // Add modal to page
      document.body.insertAdjacentHTML('beforeend', modalHtml);
    }
    
    function closeDownloadErrorModal(event) {
      if (event && event.target !== event.currentTarget) return;
      const modal = document.getElementById('downloadErrorModal');
      if (modal) modal.remove();
    }
    
    /**
     * Download asset with availability check.
     */
    function downloadAsset(assetId, filename) {
      handleDownload(`/api/assets/${assetId}/download`, filename);
    }
    
    /**
     * Download model with availability check.
     */
    function downloadModel(modelId, filename) {
      handleDownload(`/api/models/${modelId}/download`, filename);
    }
    
    // ==========================================================================
    // TRASH MANAGEMENT
    // ==========================================================================
    
    let trashData = { assets: [], models: [] };
    let currentTrashTab = 'assets';
    
    /**
     * Open Trash (now part of Settings Advanced tab).
     */
    async function openTrash() {
      openSettings();
      switchSettingsTab('advanced');
      await loadTrashContents();
    }
    
    function closeTrash() {
      closeSettings();
    }
    
    /**
     * Switch between Settings tabs.
     */
    function switchSettingsTab(tab) {
      // Update tab buttons
      document.getElementById('settingsTabGeneral').classList.toggle('active', tab === 'general');
      document.getElementById('settingsTabAdvanced').classList.toggle('active', tab === 'advanced');
      
      // Show/hide content
      document.getElementById('settingsGeneral').style.display = tab === 'general' ? 'block' : 'none';
      document.getElementById('settingsAdvanced').style.display = tab === 'advanced' ? 'block' : 'none';
      
      // Load data for advanced tab
      if (tab === 'advanced') {
        loadTrashContents();
        loadJournalStatus();
        loadSnapshotStatus();
        loadBackupPolicies();
      }
    }
    
    /**
     * Load change journal status.
     */
    async function loadJournalStatus() {
      try {
        const response = await fetch('/api/journal/status');
        if (response.ok) {
          const data = await response.json();
          const total = data.total_entries || 0;
          const recent = data.recent_24h || 0;
          document.getElementById('journalStatusText').textContent = 
            `${total} entries (${recent} in last 24h)`;
        } else {
          document.getElementById('journalStatusText').textContent = 'Available';
        }
      } catch (e) {
        document.getElementById('journalStatusText').textContent = 'Available';
      }
    }
    
    /**
     * Toggle journal entries view.
     */
    function toggleJournalView() {
      const list = document.getElementById('journalList');
      const isVisible = list.classList.contains('visible');
      
      if (isVisible) {
        list.classList.remove('visible');
        document.getElementById('viewJournalBtn').textContent = ' View Activity';
      } else {
        list.classList.add('visible');
        document.getElementById('viewJournalBtn').textContent = ' Hide Activity';
        loadJournalEntries();
      }
    }
    
    /**
     * Load journal entries.
     */
    async function loadJournalEntries() {
      const list = document.getElementById('journalList');
      const filter = document.getElementById('journalFilter').value;
      
      try {
        let url = '/api/journal?limit=50';
        if (filter) url += `&action=${filter}`;
        
        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to load');
        
        const data = await response.json();
        
        if (!data.entries || data.entries.length === 0) {
          list.innerHTML = '<div class="journal-empty">No activity recorded yet</div>';
          return;
        }
        
        list.innerHTML = data.entries.map(entry => `
          <div class="journal-entry">
            <span class="journal-action ${entry.action}">${entry.action}</span>
            <span class="journal-entity">${entry.entity_type} #${entry.entity_id}</span>
            <span class="journal-time">${formatTrashDate(entry.timestamp)}</span>
          </div>
        `).join('');
      } catch (e) {
        list.innerHTML = '<div class="journal-empty">Error loading activity</div>';
      }
    }
    
    /**
     * Load snapshot status.
     */
    async function loadSnapshotStatus() {
      try {
        const response = await fetch('/api/snapshots/latest');
        if (response.ok) {
          const data = await response.json();
          document.getElementById('lastSnapshotTime').textContent = 
            data.timestamp ? formatTrashDate(data.timestamp) : 'Never';
        } else {
          document.getElementById('lastSnapshotTime').textContent = 'Never';
        }
      } catch (e) {
        document.getElementById('lastSnapshotTime').textContent = 'Never';
      }
    }
    
    /**
     * Toggle snapshot list view.
     */
    function toggleSnapshotList() {
      const list = document.getElementById('snapshotList');
      const isVisible = list.classList.contains('visible');
      
      if (isVisible) {
        list.classList.remove('visible');
        document.getElementById('toggleSnapshotsBtn').textContent = ' View All';
      } else {
        list.classList.add('visible');
        document.getElementById('toggleSnapshotsBtn').textContent = ' Hide List';
        loadSnapshotList();
      }
    }
    
    /**
     * Load snapshot list.
     */
    async function loadSnapshotList() {
      const list = document.getElementById('snapshotList');
      
      try {
        const response = await fetch('/api/snapshots');
        if (!response.ok) throw new Error('Failed to load');
        
        const data = await response.json();
        
        if (!data.snapshots || data.snapshots.length === 0) {
          list.innerHTML = '<div class="snapshot-empty">No snapshots yet</div>';
          return;
        }
        
        list.innerHTML = data.snapshots.map(snap => `
          <div class="snapshot-item">
            <div class="snapshot-info">
              <div class="snapshot-name">${snap.filename}</div>
              <div class="snapshot-meta">${snap.size_human || '?'}  ${formatTrashDate(snap.timestamp)}</div>
            </div>
            <div class="snapshot-actions">
              <button onclick="restoreSnapshot('${snap.filename}')" title="Restore this snapshot"></button>
              <button onclick="deleteSnapshot('${snap.filename}')" title="Delete this snapshot"></button>
            </div>
          </div>
        `).join('');
      } catch (e) {
        list.innerHTML = '<div class="snapshot-empty">Error loading snapshots</div>';
      }
    }
    
    /**
     * Create database snapshot.
     */
    async function createSnapshot() {
      showToast('Creating snapshot...', 'info');
      try {
        const response = await fetch('/api/snapshots', { 
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ note: 'Manual snapshot' })
        });
        const data = await response.json();
        
        if (response.ok && data.status === 'completed') {
          showToast(`Snapshot created: ${data.size_human}`, 'success');
          loadSnapshotStatus();
          if (document.getElementById('snapshotList').classList.contains('visible')) {
            loadSnapshotList();
          }
        } else {
          showToast(data.error || 'Snapshot failed', 'error');
        }
      } catch (e) {
        showToast(`Error: ${e.message}`, 'error');
      }
    }
    
    /**
     * Restore from snapshot.
     */
    async function restoreSnapshot(filename) {
      if (!confirm(`Restore database from ${filename}?\n\nThis will replace the current database. A backup will be created first.`)) {
        return;
      }
      
      showToast('Restoring...', 'info');
      try {
        const response = await fetch(`/api/snapshots/${filename}/restore`, { method: 'POST' });
        const data = await response.json();
        
        if (response.ok && data.status === 'completed') {
          showToast('Database restored! Refresh the page.', 'success');
        } else {
          showToast(data.error || 'Restore failed', 'error');
        }
      } catch (e) {
        showToast(`Error: ${e.message}`, 'error');
      }
    }
    
    /**
     * Delete a snapshot.
     */
    async function deleteSnapshot(filename) {
      if (!confirm(`Delete snapshot ${filename}?`)) return;
      
      try {
        const response = await fetch(`/api/snapshots/${filename}`, { method: 'DELETE' });
        const data = await response.json();
        
        if (response.ok) {
          showToast('Snapshot deleted', 'success');
          loadSnapshotList();
          loadSnapshotStatus();
        } else {
          showToast(data.error || 'Delete failed', 'error');
        }
      } catch (e) {
        showToast(`Error: ${e.message}`, 'error');
      }
    }
    
    // ==================== RESTIC POLICY SNAPSHOTS ====================
    
    let currentResticPolicy = null;
    
    /**
     * Show snapshots for a Restic backup policy.
     */
    async function showPolicySnapshots(policyId) {
      // Find the policy
      const allPolicies = [...(backupPolicies.active || []), ...(backupPolicies.inactive || [])];
      const policy = allPolicies.find(p => p.id === policyId);
      
      if (!policy) {
        showToast('Policy not found', 'error');
        return;
      }
      
      if (policy.destination_type !== 'restic' && policy.destination_type !== 'restic-remote') {
        showToast('Not a Restic policy', 'error');
        return;
      }
      
      currentResticPolicy = policy;
      
      const panel = document.getElementById('resticSnapshotsPanel');
      const nameEl = document.getElementById('resticPolicyName');
      const statusEl = document.getElementById('resticSnapshotsStatus');
      const listEl = document.getElementById('resticSnapshotList');
      
      nameEl.textContent = policy.name;
      statusEl.textContent = 'Loading snapshots...';
      listEl.innerHTML = '';
      panel.style.display = 'block';
      
      // Scroll panel into view
      panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      
      try {
        const url = `/api/restic/snapshots?repo_path=${encodeURIComponent(policy.path)}&password=${encodeURIComponent(policy.restic_password)}`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (!response.ok || !data.success) {
          statusEl.textContent = ` ${data.error || 'Failed to load snapshots'}`;
          statusEl.className = 'restic-status error';
          return;
        }
        
        if (data.snapshots.length === 0) {
          statusEl.textContent = 'No snapshots yet. Run a backup first.';
          statusEl.className = 'restic-status';
          return;
        }
        
        statusEl.textContent = `${data.snapshots.length} snapshot(s) in repository`;
        statusEl.className = 'restic-status';
        
        // Render snapshot list
        listEl.innerHTML = data.snapshots.map(snap => {
          const time = new Date(snap.time).toLocaleString();
          const tags = snap.tags.length ? snap.tags.join(', ') : '';
          return `
            <div class="snapshot-item">
              <div class="snapshot-info">
                <span class="snapshot-name">${snap.id}</span>
                <span class="snapshot-meta">${time}${tags ? '  ' + tags : ''}</span>
              </div>
              <div class="snapshot-actions">
                <button onclick="restoreFromPolicy('${snap.full_id}')" title="Restore this snapshot"> Restore</button>
              </div>
            </div>
          `;
        }).join('');
        
        // Show the list
        listEl.style.display = 'block';
        
      } catch (e) {
        statusEl.textContent = ` Error: ${e.message}`;
        statusEl.className = 'restic-status error';
      }
    }
    
    /**
     * Close the Restic snapshots panel.
     */
    function closeResticSnapshots() {
      document.getElementById('resticSnapshotsPanel').style.display = 'none';
      currentResticPolicy = null;
    }
    
    /**
     * Restore database from a policy's Restic snapshot.
     */
    async function restoreFromPolicy(snapshotId) {
      if (!currentResticPolicy) {
        showToast('No policy selected', 'error');
        return;
      }
      
      if (!confirm(`Restore database from snapshot ${snapshotId.substring(0, 8)}?\n\nThis will:\n1. Create a safety backup of current database\n2. Restore the selected snapshot\n3. Replace the current database\n\nContinue?`)) {
        return;
      }
      
      const statusEl = document.getElementById('resticSnapshotsStatus');
      statusEl.textContent = ' Restoring... (this may take a moment)';
      statusEl.className = 'restic-status';
      
      try {
        const response = await fetch('/api/restic/restore', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            repo_path: currentResticPolicy.path,
            password: currentResticPolicy.restic_password,
            snapshot_id: snapshotId
          })
        });
        
        const data = await response.json();
        
        if (response.ok && data.success) {
          statusEl.textContent = ` ${data.message}  Reloading in 3 seconds...`;
          statusEl.className = 'restic-status success';
          showToast('Database restored! Reloading...', 'success');
          
          // Auto-reload after 3 seconds
          setTimeout(() => {
            window.location.reload();
          }, 3000);
        } else {
          statusEl.textContent = ` ${data.error || 'Restore failed'}`;
          statusEl.className = 'restic-status error';
          showToast(data.error || 'Restore failed', 'error');
        }
      } catch (e) {
        statusEl.textContent = ` Error: ${e.message}`;
        statusEl.className = 'restic-status error';
        showToast(`Error: ${e.message}`, 'error');
      }
    }
    
    let backupPolicies = { active: [], inactive: [], policies: [] };
    
    /**
     * Load backup policies from API.
     */
    async function loadBackupPolicies() {
      try {
        const response = await fetch('/api/backup/policies');
        if (response.ok) {
          backupPolicies = await response.json();
          renderPolicyTables();
        }
      } catch (e) {
        console.error('Failed to load backup policies:', e);
      }
    }
    
    /**
     * Render policy tables (active and inactive).
     */
    function renderPolicyTables() {
      const activeList = document.getElementById('activePoliciesList');
      const inactiveList = document.getElementById('inactivePoliciesList');
      
      // Render active policies
      if (backupPolicies.active && backupPolicies.active.length > 0) {
        activeList.innerHTML = backupPolicies.active.map(p => renderPolicyRow(p)).join('');
      } else {
        activeList.innerHTML = '<div class="policy-empty">No active policies</div>';
      }
      
      // Render inactive policies
      if (backupPolicies.inactive && backupPolicies.inactive.length > 0) {
        inactiveList.innerHTML = backupPolicies.inactive.map(p => renderPolicyRow(p)).join('');
      } else {
        inactiveList.innerHTML = '<div class="policy-empty">No inactive policies</div>';
      }
    }
    
    /**
     * Render a single policy row.
     */
    function renderPolicyRow(policy) {
      const destType = policy.destination_type || 'local';
      const isRestic = destType === 'restic' || destType === 'restic-remote';
      let destDisplay;
      if (destType === 'network') {
        destDisplay = `<span class="dest-type network">SSH</span>${policy.ssh_host}:${policy.path}`;
      } else if (destType === 'restic') {
        destDisplay = `<span class="dest-type restic">Restic</span>${policy.path}`;
      } else if (destType === 'restic-remote') {
        destDisplay = `<span class="dest-type restic">Restic </span>${policy.path}`;
      } else {
        destDisplay = `<span class="dest-type local">Local</span>${policy.path}`;
      }
      
      const lastBackup = policy.last_backup ? formatTrashDate(policy.last_backup) : '';
      const nextScheduled = policy.next_scheduled ? formatTrashDate(policy.next_scheduled) : '';
      
      // Add Snapshots button for Restic policies (both local and remote)
      const snapshotsBtn = isRestic 
        ? `<button onclick="showPolicySnapshots('${policy.id}')" title="View snapshots & restore" class="snapshots-btn"> Snapshots</button>`
        : '';
      
      return `
        <div class="policy-row" data-id="${policy.id}">
          <span class="col-name">${escapeHtml(policy.name)}</span>
          <span class="col-dest" title="${escapeHtml(policy.path)}">${destDisplay}</span>
          <span class="col-freq">${policy.frequency}</span>
          <span class="col-last">${lastBackup}</span>
          <span class="col-next">${nextScheduled}</span>
          <span class="col-state">
            <select class="state-select" onchange="updatePolicyState('${policy.id}', this.value)">
              <option value="active" ${policy.state === 'active' ? 'selected' : ''}>Active</option>
              <option value="paused" ${policy.state === 'paused' ? 'selected' : ''}>Paused</option>
              <option value="disabled" ${policy.state === 'disabled' ? 'selected' : ''}>Disabled</option>
            </select>
          </span>
          <span class="col-actions">
            ${snapshotsBtn}
            <button onclick="runPolicyBackup('${policy.id}')" title="Run now"></button>
            <button onclick="deletePolicy('${policy.id}')" title="Delete"></button>
          </span>
        </div>
      `;
    }
    
    /**
     * Server-side directory browser state.
     */
    let dirBrowserCurrentPath = '';
    let dirBrowserTargetInput = null;
    
    /**
     * Browse for backup directory path (server-side).
     */
    function browseBackupPath() {
      dirBrowserTargetInput = document.getElementById('newPolicyPath');
      const startPath = dirBrowserTargetInput.value || '';
      openDirBrowser(startPath);
    }
    
    /**
     * Open directory browser modal.
     */
    async function openDirBrowser(startPath = '') {
      document.getElementById('dirBrowserModal').classList.add('active');
      await loadDirectory(startPath);
    }
    
    /**
     * Close directory browser modal.
     */
    function closeDirBrowser() {
      document.getElementById('dirBrowserModal').classList.remove('active');
    }
    
    /**
     * Load directory listing from server.
     */
    async function loadDirectory(path = '') {
      const listEl = document.getElementById('dirBrowserList');
      const pathEl = document.getElementById('dirBrowserPath');
      
      listEl.innerHTML = '<div class="dir-browser-empty">Loading...</div>';
      
      try {
        const url = path ? `/api/browse-directories?path=${encodeURIComponent(path)}` : '/api/browse-directories';
        const resp = await fetch(url);
        const data = await resp.json();
        
        if (!resp.ok) {
          listEl.innerHTML = `<div class="dir-browser-empty"> ${data.error || 'Failed to load'}</div>`;
          return;
        }
        
        dirBrowserCurrentPath = data.current_path;
        pathEl.textContent = data.current_path;
        
        // Build list with event delegation
        listEl.innerHTML = '';
        
        // Parent directory link
        if (data.parent_path) {
          const parentEl = document.createElement('div');
          parentEl.className = 'dir-browser-item parent-dir';
          parentEl.innerHTML = '<span class="icon"></span><span class="name">..</span>';
          parentEl.addEventListener('click', () => loadDirectory(data.parent_path));
          listEl.appendChild(parentEl);
        }
        
        // Directory listing
        if (data.directories.length === 0) {
          listEl.innerHTML += '<div class="dir-browser-empty">No subdirectories</div>';
        } else {
          for (const dir of data.directories) {
            const itemEl = document.createElement('div');
            itemEl.className = 'dir-browser-item' + (!dir.readable ? ' disabled' : '');
            itemEl.innerHTML = `
              <span class="icon"></span>
              <span class="name">${escapeHtml(dir.name)}</span>
              ${!dir.readable ? '<span style="color:var(--text-secondary);font-size:0.8rem;"></span>' : ''}
            `;
            if (dir.readable) {
              itemEl.addEventListener('click', () => loadDirectory(dir.path));
            }
            listEl.appendChild(itemEl);
          }
        }
        
      } catch (err) {
        listEl.innerHTML = `<div class="dir-browser-empty"> ${err.message}</div>`;
      }
    }
    
    /**
     * Select current directory and close browser.
     */
    function selectCurrentDir() {
      if (dirBrowserTargetInput && dirBrowserCurrentPath) {
        dirBrowserTargetInput.value = dirBrowserCurrentPath;
      }
      closeDirBrowser();
    }
    
    /**
     * Create a new folder in the current directory.
     */
    async function createNewFolder() {
      const nameInput = document.getElementById('newFolderInput');
      const folderName = nameInput.value.trim();
      
      if (!folderName) {
        showToast('Enter a folder name', 'error');
        return;
      }
      
      if (!dirBrowserCurrentPath) {
        showToast('No directory selected', 'error');
        return;
      }
      
      try {
        const resp = await fetch('/api/create-directory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            path: dirBrowserCurrentPath,
            name: folderName
          })
        });
        
        const data = await resp.json();
        
        if (!resp.ok) {
          showToast(data.error || 'Failed to create folder', 'error');
          return;
        }
        
        showToast(`Created: ${folderName}`, 'success');
        nameInput.value = '';
        
        // Refresh and navigate into the new folder
        await loadDirectory(data.path);
        
      } catch (err) {
        showToast('Error creating folder: ' + err.message, 'error');
      }
    }
    
    /**
     * Toggle destination-specific fields visibility.
     */
    function toggleDestinationFields() {
      // Clear any previous validation messages
      const msgEl = document.getElementById('policyValidationMsg');
      if (msgEl) {
        msgEl.textContent = '';
        msgEl.className = 'policy-validation-msg';
      }
      
      const destType = document.getElementById('newPolicyDestType').value;
      const isNetwork = destType === 'network';
      const isResticLocal = destType === 'restic';
      const isResticRemote = destType === 'restic-remote';
      const isRestic = isResticLocal || isResticRemote;
      const isLocal = destType === 'local';
      
      // SSH host field (network only - restic-remote uses path format)
      document.getElementById('newPolicySshHost').style.display = isNetwork ? 'block' : 'none';
      
      // SSH key fields (network and restic-remote)
      document.getElementById('networkFields').style.display = (isNetwork || isResticRemote) ? 'flex' : 'none';
      
      // Restic password fields (with confirmation)
      document.getElementById('newPolicyResticPassword').style.display = isRestic ? 'block' : 'none';
      document.getElementById('newPolicyResticPasswordConfirm').style.display = isRestic ? 'block' : 'none';
      
      // Browse button (show for local and restic-local only)
      document.getElementById('localPathWrapper').querySelector('.browse-btn').style.display = (isLocal || isResticLocal) ? 'inline-block' : 'none';
      
      // Update path placeholder
      const pathInput = document.getElementById('newPolicyPath');
      if (isResticRemote) {
        pathInput.placeholder = 'sftp:laptop:/path or sftp:user@192.168.1.1:/path';
      } else if (isResticLocal) {
        pathInput.placeholder = '/path/to/restic-repo';
      } else if (isNetwork) {
        pathInput.placeholder = '/remote/path/to/backups';
      } else {
        pathInput.placeholder = '/path/to/backups';
      }
    }
    
    // Alias for backward compatibility
    function toggleNetworkFields() { toggleDestinationFields(); }
    
    // Track selected SSH key for the modal
    let selectedSshKeyPath = null;
    let sshKeysCache = [];
    
    /**
     * Show SSH key help modal and load available keys.
     */
    async function showSshKeyHelp() {
      document.getElementById('sshKeyHelpModal').classList.add('active');
      selectedSshKeyPath = null;
      
      // Show loading state
      document.getElementById('sshKeyLoading').style.display = 'block';
      document.getElementById('sshKeyOptions').style.display = 'none';
      document.getElementById('sshKeyInfo').style.display = 'none';
      document.getElementById('useSshKeyBtn').style.display = 'none';
      document.getElementById('sshTestResult').innerHTML = '';
      
      try {
        // Load all available keys
        const response = await fetch('/api/ssh/keys');
        const data = await response.json();
        sshKeysCache = data.keys || [];
        
        // Populate dropdown
        const select = document.getElementById('sshKeySelect');
        select.innerHTML = '<option value="">-- Select a key --</option>';
        
        sshKeysCache.forEach(key => {
          const opt = document.createElement('option');
          opt.value = key.path;
          opt.textContent = `${key.name} (${key.type})${key.comment ? ' - ' + key.comment : ''}`;
          select.appendChild(opt);
        });
        
        document.getElementById('sshKeyLoading').style.display = 'none';
        document.getElementById('sshKeyOptions').style.display = 'block';
        
      } catch (e) {
        document.getElementById('sshKeyLoading').textContent = ' Error loading keys';
      }
    }
    
    /**
     * Handle key selection from dropdown.
     */
    async function onSshKeySelected() {
      const select = document.getElementById('sshKeySelect');
      const path = select.value;
      
      if (!path) {
        document.getElementById('sshKeyInfo').style.display = 'none';
        document.getElementById('useSshKeyBtn').style.display = 'none';
        selectedSshKeyPath = null;
        return;
      }
      
      selectedSshKeyPath = path;
      
      // Find key in cache to get public key
      const key = sshKeysCache.find(k => k.path === path);
      document.getElementById('sshKeyPathDisplay').textContent = path;
      
      // Load public key
      try {
        const pubPath = path + '.pub';
        // We need to fetch the public key content - use a simple endpoint or read from cache
        // For now, show the path and let user know
        const pubResponse = await fetch(`/api/ssh/key/public?path=${encodeURIComponent(path)}`);
        if (pubResponse.ok) {
          const pubData = await pubResponse.json();
          document.getElementById('sshPublicKeyDisplay').textContent = pubData.public_key || 'Unable to load public key';
        } else {
          document.getElementById('sshPublicKeyDisplay').textContent = 'Public key file: ' + path + '.pub';
        }
      } catch (e) {
        document.getElementById('sshPublicKeyDisplay').textContent = 'Public key file: ' + path + '.pub';
      }
      
      document.getElementById('sshKeyInfo').style.display = 'block';
      document.getElementById('useSshKeyBtn').style.display = 'inline-block';
    }
    
    /**
     * Generate a new SSH key.
     */
    async function generateSshKey() {
      const btn = document.getElementById('generateKeyBtn');
      btn.disabled = true;
      btn.textContent = ' Creating...';
      
      try {
        const response = await fetch('/api/ssh/key', { method: 'POST' });
        const data = await response.json();
        
        if (response.ok && data.success) {
          showToast('SSH key created!', 'success');
          // Reload to show the new key in dropdown
          await showSshKeyHelp();
          // Auto-select the new key
          document.getElementById('sshKeySelect').value = data.key_path;
          await onSshKeySelected();
        } else {
          showToast(data.error || 'Failed to create key', 'error');
          btn.disabled = false;
          btn.textContent = ' Create New Key';
        }
      } catch (e) {
        showToast('Error: ' + e.message, 'error');
        btn.disabled = false;
        btn.textContent = ' Create New Key';
      }
    }
    
    /**
     * Test SSH connection from the modal.
     */
    async function testSshConnectionFromModal() {
      const host = document.getElementById('sshTestHost').value.trim();
      const resultEl = document.getElementById('sshTestResult');
      const btn = document.getElementById('sshTestBtn');
      
      if (!host) {
        resultEl.innerHTML = '<span style="color: #ff6b6b;">Enter a host (e.g., user@hostname)</span>';
        return;
      }
      
      btn.disabled = true;
      btn.textContent = ' Testing...';
      resultEl.innerHTML = '<span style="color: var(--text-secondary);">Connecting...</span>';
      
      try {
        const response = await fetch('/api/ssh/test', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ host, key_path: selectedSshKeyPath })
        });
        const data = await response.json();
        
        if (data.success) {
          resultEl.innerHTML = '<span style="color: #40c057;"> Connection successful!</span>';
        } else {
          resultEl.innerHTML = `<span style="color: #ff6b6b;"> ${data.error || 'Connection failed'}</span>`;
        }
      } catch (e) {
        resultEl.innerHTML = `<span style="color: #ff6b6b;"> Error: ${e.message}</span>`;
      }
      
      btn.disabled = false;
      btn.textContent = ' Test';
    }
    
    /**
     * Copy public key to clipboard.
     */
    function copySshPublicKey() {
      const publicKey = document.getElementById('sshPublicKeyDisplay').textContent;
      navigator.clipboard.writeText(publicKey).then(() => {
        showToast('Public key copied to clipboard!', 'success');
      }).catch(() => {
        showToast('Failed to copy - please select and copy manually', 'error');
      });
    }
    
    /**
     * Use the SSH key - fill in the key path field.
     */
    function useSshKey() {
      const keyPath = selectedSshKeyPath || document.getElementById('sshKeyPathDisplay').textContent;
      if (!keyPath) {
        showToast('Please select a key first', 'error');
        return;
      }
      document.getElementById('newPolicySshKey').value = keyPath;
      closeSshKeyHelp();
      showToast('SSH key path filled in', 'success');
    }
    
    /**
     * Close SSH key help modal.
     */
    function closeSshKeyHelp() {
      document.getElementById('sshKeyHelpModal').classList.remove('active');
    }
    
    /**
     * Save new policy.
     */
    async function saveNewPolicy() {
      const msgEl = document.getElementById('policyValidationMsg');
      msgEl.textContent = '';
      msgEl.className = 'policy-validation-msg';
      
      const policyData = {
        name: document.getElementById('newPolicyName').value.trim(),
        destination_type: document.getElementById('newPolicyDestType').value,
        path: document.getElementById('newPolicyPath').value.trim(),
        frequency: document.getElementById('newPolicyFrequency').value,
        schedule_time: document.getElementById('newPolicyTime').value || '02:00',
        start_date: document.getElementById('newPolicyStartDate').value || null,
        retention_count: parseInt(document.getElementById('newPolicyRetention').value) || 7,
        state: document.getElementById('newPolicyState').value,
        ssh_host: document.getElementById('newPolicySshHost').value.trim(),
        ssh_key_path: document.getElementById('newPolicySshKey').value.trim(),
        restic_password: document.getElementById('newPolicyResticPassword').value
      };
      
      // Basic validation
      if (!policyData.name) {
        msgEl.textContent = ' Policy name is required';
        msgEl.className = 'policy-validation-msg error';
        return;
      }
      
      if (!policyData.path) {
        msgEl.textContent = ' Destination path is required';
        msgEl.className = 'policy-validation-msg error';
        return;
      }
      
      if (policyData.retention_count < 1) {
        msgEl.textContent = ' Retention must be at least 1 copy';
        msgEl.className = 'policy-validation-msg error';
        return;
      }
      
      if (policyData.destination_type === 'network' && !policyData.ssh_host) {
        msgEl.textContent = ' SSH host is required for network backups';
        msgEl.className = 'policy-validation-msg error';
        return;
      }
      
      if (policyData.destination_type === 'restic' || policyData.destination_type === 'restic-remote') {
        if (!policyData.restic_password) {
          msgEl.textContent = ' Repository password is required for Restic backups';
          msgEl.className = 'policy-validation-msg error';
          return;
        }
        const confirmPassword = document.getElementById('newPolicyResticPasswordConfirm').value;
        if (policyData.restic_password !== confirmPassword) {
          msgEl.textContent = ' Passwords do not match';
          msgEl.className = 'policy-validation-msg error';
          return;
        }
        // Validate remote format
        if (policyData.destination_type === 'restic-remote' && !policyData.path.startsWith('sftp:')) {
          msgEl.textContent = ' Remote path must start with sftp: (e.g., sftp:user@host:/path)';
          msgEl.className = 'policy-validation-msg error';
          return;
        }
      }
      
      msgEl.textContent = ' Validating...';
      
      try {
        // Validate first
        const validateResponse = await fetch('/api/backup/policies/validate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(policyData)
        });
        
        const validateResult = await validateResponse.json();
        
        if (!validateResponse.ok) {
          msgEl.textContent = ` ${validateResult.error}`;
          msgEl.className = 'policy-validation-msg error';
          return;
        }
        
        // Create policy
        const createResponse = await fetch('/api/backup/policies', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(policyData)
        });
        
        const createResult = await createResponse.json();
        
        if (createResponse.ok && createResult.success) {
          msgEl.textContent = ' Policy created successfully';
          msgEl.className = 'policy-validation-msg success';
          
          // Clear form
          document.getElementById('newPolicyName').value = '';
          document.getElementById('newPolicyPath').value = '';
          document.getElementById('newPolicySshHost').value = '';
          document.getElementById('newPolicySshKey').value = '';
          document.getElementById('newPolicyResticPassword').value = '';
          document.getElementById('newPolicyResticPasswordConfirm').value = '';
          document.getElementById('newPolicyState').value = 'disabled';
          
          // Reload policies
          await loadBackupPolicies();
          
          showToast('Policy created', 'success');
        } else {
          msgEl.textContent = ` ${createResult.error || 'Failed to create policy'}`;
          msgEl.className = 'policy-validation-msg error';
        }
      } catch (e) {
        msgEl.textContent = ` Error: ${e.message}`;
        msgEl.className = 'policy-validation-msg error';
      }
    }
    
    /**
     * Test network connection for new policy.
     */
    async function testPolicyConnection() {
      const msgEl = document.getElementById('policyValidationMsg');
      const destType = document.getElementById('newPolicyDestType').value;
      let host = document.getElementById('newPolicySshHost').value.trim();
      const path = document.getElementById('newPolicyPath').value.trim();
      const keyPath = document.getElementById('newPolicySshKey').value.trim();
      
      console.log('Test connection:', { destType, host, path, keyPath });
      
      // For Restic Remote, extract host from path field
      // Formats: sftp:user@host:/path, sftp:alias:/path, user@host:/path, alias:/path
      if (destType === 'restic-remote' && !host && path) {
        // Remove sftp: prefix if present
        let cleanPath = path.replace(/^sftp:/, '');
        // Extract host part (everything before the first :)
        const colonIdx = cleanPath.indexOf(':');
        if (colonIdx > 0) {
          host = cleanPath.substring(0, colonIdx);
        }
        console.log('Extracted host:', host, 'from cleanPath:', cleanPath);
      }
      
      if (!host) {
        msgEl.textContent = ' Could not extract host from path. Use format: sftp:hostname:/path';
        msgEl.className = 'policy-validation-msg error';
        return;
      }
      
      msgEl.textContent = ' Testing connection...';
      
      try {
        const response = await fetch('/api/ssh/test', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ host, key_path: keyPath })
        });
        
        const result = await response.json();
        
        if (result.success) {
          msgEl.textContent = ' Connection successful';
          msgEl.className = 'policy-validation-msg success';
        } else {
          msgEl.textContent = ` Connection failed: ${result.error}`;
          msgEl.className = 'policy-validation-msg error';
        }
      } catch (e) {
        msgEl.textContent = ` Error: ${e.message}`;
        msgEl.className = 'policy-validation-msg error';
      }
    }
    
    /**
     * Update policy state.
     */
    async function updatePolicyState(policyId, newState) {
      try {
        const response = await fetch(`/api/backup/policies/${policyId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ state: newState })
        });
        
        const result = await response.json();
        
        if (response.ok && result.success) {
          showToast(`Policy ${newState}`, 'success');
          await loadBackupPolicies();
        } else {
          showToast(result.error || 'Update failed', 'error');
          await loadBackupPolicies(); // Reload to reset dropdown
        }
      } catch (e) {
        showToast(`Error: ${e.message}`, 'error');
      }
    }
    
    /**
     * Run backup for a specific policy.
     */
    async function runPolicyBackup(policyId) {
      showToast('Running backup...', 'info');
      
      try {
        const response = await fetch(`/api/backup/policies/${policyId}/run`, { method: 'POST' });
        const result = await response.json();
        
        if (result.success) {
          showToast(`Backup complete: ${result.destination || 'Success'}`, 'success');
          await loadBackupPolicies();
        } else {
          showToast(result.error || 'Backup failed', 'error');
        }
      } catch (e) {
        showToast(`Error: ${e.message}`, 'error');
      }
    }
    
    /**
     * Delete a policy.
     */
    async function deletePolicy(policyId) {
      if (!confirm('Delete this backup policy?')) return;
      
      try {
        const response = await fetch(`/api/backup/policies/${policyId}`, { method: 'DELETE' });
        const result = await response.json();
        
        if (result.success) {
          showToast('Policy deleted', 'success');
          await loadBackupPolicies();
        } else {
          showToast(result.error || 'Delete failed', 'error');
        }
      } catch (e) {
        showToast(`Error: ${e.message}`, 'error');
      }
    }
    
    /**
     * Load trash contents from API.
     */
    async function loadTrashContents() {
      try {
        const response = await fetch('/api/trash');
        if (!response.ok) throw new Error('Failed to load trash');
        
        trashData = await response.json();
        
        // Update counts
        document.getElementById('trashAssetCount').textContent = trashData.total_assets || 0;
        document.getElementById('trashModelCount').textContent = trashData.total_models || 0;
        
        // Update summary
        const total = (trashData.total_assets || 0) + (trashData.total_models || 0);
        document.getElementById('trashSummary').innerHTML = `
          <span class="trash-count">${total} item${total !== 1 ? 's' : ''} in trash</span>
        `;
        
        // Update badge in header
        updateTrashBadge(total);
        
        // Enable/disable empty button
        document.getElementById('emptyTrashBtn').disabled = total === 0;
        
        // Render current tab
        renderTrashList();
      } catch (e) {
        console.error('Error loading trash:', e);
        document.getElementById('trashList').innerHTML = `
          <div class="trash-empty">Error loading trash: ${e.message}</div>
        `;
      }
    }
    
    /**
     * Update the trash badge in header.
     */
    function updateTrashBadge(count) {
      const badge = document.getElementById('trashBadge');
      if (count > 0) {
        badge.textContent = count > 99 ? '99+' : count;
        badge.style.display = 'flex';
      } else {
        badge.style.display = 'none';
      }
    }
    
    /**
     * Switch between assets and models tabs.
     */
    function switchTrashTab(tab) {
      currentTrashTab = tab;
      document.getElementById('trashTabAssets').classList.toggle('active', tab === 'assets');
      document.getElementById('trashTabModels').classList.toggle('active', tab === 'models');
      renderTrashList();
    }
    
    /**
     * Render the trash list for current tab.
     */
    function renderTrashList() {
      const container = document.getElementById('trashList');
      const items = currentTrashTab === 'assets' ? trashData.assets : trashData.models;
      const type = currentTrashTab === 'assets' ? 'asset' : 'model';
      const icon = currentTrashTab === 'assets' ? '' : '';
      
      if (!items || items.length === 0) {
        container.innerHTML = `<div class="trash-empty">No ${type}s in trash</div>`;
        return;
      }
      
      container.innerHTML = items.map(item => `
        <div class="trash-item" data-id="${item.id}" data-type="${type}">
          <div class="trash-item-icon">${icon}</div>
          <div class="trash-item-info">
            <div class="trash-item-name">${escapeHtml(item.title || item.filename)}</div>
            <div class="trash-item-meta">
              Deleted: ${formatTrashDate(item.deleted_at)}
              ${item.file_size ? `  ${formatSize(item.file_size)}` : ''}
            </div>
          </div>
          <div class="trash-item-actions">
            <button class="restore-btn" onclick="restoreItem('${type}', ${item.id})"> Restore</button>
            <button class="delete-btn" onclick="permanentlyDelete('${type}', ${item.id})"> Delete</button>
          </div>
        </div>
      `).join('');
    }
    
    /**
     * Format deletion date.
     */
    function formatTrashDate(isoDate) {
      if (!isoDate) return 'Unknown';
      const date = new Date(isoDate);
      const now = new Date();
      const diffMs = now - date;
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      const diffDays = Math.floor(diffHours / 24);
      
      if (diffHours < 1) return 'Just now';
      if (diffHours < 24) return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
      if (diffDays < 7) return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
      return date.toLocaleDateString();
    }
    
    /**
     * Restore an item from trash.
     */
    async function restoreItem(type, id) {
      try {
        const response = await fetch(`/api/trash/${type}/${id}/restore`, { method: 'POST' });
        const data = await response.json();
        
        if (response.ok) {
          showToast(data.message || 'Item restored', 'success');
          await loadTrashContents();
          loadStats();  // Refresh main stats
        } else {
          showToast(data.error || 'Failed to restore', 'error');
        }
      } catch (e) {
        showToast(`Error: ${e.message}`, 'error');
      }
    }
    
    /**
     * Permanently delete an item.
     */
    async function permanentlyDelete(type, id) {
      if (!confirm('Permanently delete this item? This cannot be undone.')) return;
      
      try {
        const response = await fetch(`/api/trash/${type}/${id}/permanent`, { method: 'DELETE' });
        const data = await response.json();
        
        if (response.ok) {
          showToast(data.message || 'Item permanently deleted', 'success');
          await loadTrashContents();
        } else {
          showToast(data.error || 'Failed to delete', 'error');
        }
      } catch (e) {
        showToast(`Error: ${e.message}`, 'error');
      }
    }
    
    /**
     * Empty entire trash.
     */
    async function emptyTrash() {
      const total = (trashData.total_assets || 0) + (trashData.total_models || 0);
      if (!confirm(`Permanently delete all ${total} items in trash? This cannot be undone.`)) return;
      
      try {
        const response = await fetch('/api/trash/empty', { method: 'POST' });
        const data = await response.json();
        
        if (response.ok) {
          showToast(data.message || 'Trash emptied', 'success');
          await loadTrashContents();
          loadStats();
        } else {
          showToast(data.error || 'Failed to empty trash', 'error');
        }
      } catch (e) {
        showToast(`Error: ${e.message}`, 'error');
      }
    }
    
    /**
     * Check trash count on page load (for badge).
     */
    async function checkTrashCount() {
      try {
        const response = await fetch('/api/trash');
        if (response.ok) {
          const data = await response.json();
          const total = (data.total_assets || 0) + (data.total_models || 0);
          updateTrashBadge(total);
        }
      } catch (e) {
        // Silently fail - badge just won't show
      }
    }
    
    // Check trash count on load
    document.addEventListener('DOMContentLoaded', checkTrashCount);
    
    // ==========================================================================
    // SIDEBAR RESIZE HANDLE
    // ==========================================================================
    
    (function() {
      const handle = document.getElementById('resizeHandle');
      const sidebar = document.getElementById('sidebar');
      let isDragging = false;
      
      handle.addEventListener('mousedown', (e) => {
        isDragging = true;
        handle.classList.add('dragging');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const newWidth = e.clientX;
        if (newWidth >= 150 && newWidth <= window.innerWidth * 0.7) {
          sidebar.style.width = newWidth + 'px';
        }
      });
      
      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          handle.classList.remove('dragging');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
        }
      });
    })();

    // 
    // CONTEXT MENU FUNCTIONS
    // 
    
    function showContextMenu(menuId, x, y) {
      const menu = document.getElementById(menuId);
      menu.style.display = 'block';
      // Get actual menu dimensions after display
      const rect = menu.getBoundingClientRect();
      const menuWidth = rect.width || 220;
      const menuHeight = rect.height || 200;
      // Position at cursor, but keep within viewport
      menu.style.left = Math.min(x, window.innerWidth - menuWidth - 10) + 'px';
      menu.style.top = Math.min(y, window.innerHeight - menuHeight - 10) + 'px';
    }
    
    async function contextMenuRefresh() {
      document.getElementById('folderContextMenu').style.display = 'none';
      if (contextMenuPath) {
        filterFolder(contextMenuPath);
      } else {
        // Refresh based on current content type
        if (contentType === '3d') {
          load3dFolders();
          load3dModels();
        } else {
          loadFolders();
          loadAssets();
        }
      }
    }
    
    async function contextMenuForceIndex() {
      document.getElementById('folderContextMenu').style.display = 'none';
      let path = contextMenuPath || currentFolder;
      if (!path) {
        showNotification('No folder selected', 'error');
        return;
      }
      
      // Convert relative folder path to absolute system path
      // contextMenuPath is relative like "Upload-test1" but backend needs "/content/3d-models/Upload-test1"
      if (!path.startsWith('/')) {
        // Get root path based on content type
        const root = contentType === '3d' ? '/content/3d-models' : '/content/pdfs';
        path = root + '/' + path;
      }
      
      console.log('Force index on path:', path);
      showNotification('Starting index...', 'info');
      
      try {
        const res = await fetch('/api/index/directory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path, force: true, recursive: true })
        });
        const data = await res.json();
        
        if (res.ok) {
          showNotification(`Indexed: ${data.new} new, ${data.update} updated, ${data.skip} skipped`, 'success');
          // Refresh the appropriate content type
          if (contentType === 'pdf') {
            loadFolders();
            loadAssets();
          } else {
            load3dFolders();
            load3dModels();
          }
        } else {
          showNotification(data.error || 'Index failed', 'error');
        }
      } catch (e) {
        showNotification('Index failed: ' + e.message, 'error');
      }
    }
    
    async function contextMenuForceThumbs() {
      document.getElementById('folderContextMenu').style.display = 'none';
      showNotification('Thumbnail rendering queued (runs in background)', 'info');
      
      try {
        const res = await fetch('/api/thumbnails/render/pending', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ limit: 100 })
        });
        const data = await res.json();
        
        if (res.ok) {
          showNotification(`Rendered: ${data.rendered}, Failed: ${data.failed}`, 'success');
        }
      } catch (e) {
        showNotification('Thumbnail render failed', 'error');
      }
    }
    
    async function contextMenuShowStatus() {
      document.getElementById('folderContextMenu').style.display = 'none';
      
      try {
        const res = await fetch('/api/models/index-stats');
        const stats = await res.json();
        
        const html = `
          <div style="padding: 20px;">
            <h2 style="margin-bottom: 20px;"> Index Status</h2>
            <table style="width: 100%; border-collapse: collapse;">
              <tr><td style="padding: 8px; border-bottom: 1px solid var(--border);">Total Models</td>
                  <td style="padding: 8px; border-bottom: 1px solid var(--border); text-align: right;">${stats.total?.toLocaleString() || 0}</td></tr>
              <tr><td style="padding: 8px; border-bottom: 1px solid var(--border);">With Hash</td>
                  <td style="padding: 8px; border-bottom: 1px solid var(--border); text-align: right;">${stats.with_hash?.toLocaleString() || 0}</td></tr>
              <tr><td style="padding: 8px; border-bottom: 1px solid var(--border);">With Thumbnail</td>
                  <td style="padding: 8px; border-bottom: 1px solid var(--border); text-align: right;">${stats.with_thumbnail?.toLocaleString() || 0}</td></tr>
              <tr><td style="padding: 8px; border-bottom: 1px solid var(--border);">Missing</td>
                  <td style="padding: 8px; border-bottom: 1px solid var(--border); text-align: right; color: ${stats.missing_count > 0 ? '#ff6b6b' : 'inherit'};">${stats.missing_count || 0}</td></tr>
              <tr><td style="padding: 8px; border-bottom: 1px solid var(--border);">Offline</td>
                  <td style="padding: 8px; border-bottom: 1px solid var(--border); text-align: right;">${stats.offline_count || 0}</td></tr>
            </table>
            ${Object.keys(stats.by_status || {}).length > 0 ? `
              <h3 style="margin: 20px 0 10px;">By Status</h3>
              <table style="width: 100%; border-collapse: collapse;">
                ${Object.entries(stats.by_status || {}).map(([k, v]) => `
                  <tr><td style="padding: 8px; border-bottom: 1px solid var(--border);">${k}</td>
                      <td style="padding: 8px; border-bottom: 1px solid var(--border); text-align: right;">${v.toLocaleString()}</td></tr>
                `).join('')}
              </table>
            ` : ''}
          </div>
        `;
        
        document.getElementById('modalBody').innerHTML = html;
        document.getElementById('modal').classList.add('show');
      } catch (e) {
        showNotification('Failed to load stats', 'error');
      }
    }
    
    // Asset context menu functions
    let contextMenuAssetType = 'model';  // 'model' or 'pdf'
    
    function showAssetContextMenu(e, assetId, assetType = 'model') {
      e.preventDefault();
      e.stopPropagation();
      contextMenuAssetId = assetId;
      contextMenuAssetType = assetType;
      showContextMenu('assetContextMenu', e.clientX, e.clientY);
    }
    
    function contextMenuViewAsset() {
      document.getElementById('assetContextMenu').style.display = 'none';
      if (contextMenuAssetId) {
        if (contextMenuAssetType === 'pdf') {
          showDetail(contextMenuAssetId);
        } else {
          show3dDetail(contextMenuAssetId);
        }
      }
    }
    
    async function contextMenuDownloadAsset() {
      document.getElementById('assetContextMenu').style.display = 'none';
      if (contextMenuAssetId) {
        const endpoint = contextMenuAssetType === 'pdf' ? 'assets' : 'models';
        window.open(`/api/${endpoint}/${contextMenuAssetId}/download`, '_blank');
      }
    }
    
    async function contextMenuReindexAsset() {
      document.getElementById('assetContextMenu').style.display = 'none';
      if (!contextMenuAssetId) return;
      
      showNotification('Re-indexing...', 'info');
      
      try {
        const endpoint = contextMenuAssetType === 'pdf' ? 'assets' : 'models';
        const res = await fetch(`/api/${endpoint}/${contextMenuAssetId}/reindex`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ force: true })
        });
        const data = await res.json();
        
        if (res.ok) {
          showNotification(`Status: ${data.status} - ${data.reason || ''}`, 'success');
        } else {
          showNotification(data.error || 'Re-index failed', 'error');
        }
      } catch (e) {
        showNotification('Re-index failed', 'error');
      }
    }
    
    async function contextMenuRegenThumb() {
      document.getElementById('assetContextMenu').style.display = 'none';
      if (!contextMenuAssetId) return;
      
      showNotification('Regenerating thumbnail...', 'info');
      
      try {
        const endpoint = contextMenuAssetType === 'pdf' ? 'assets' : 'models';
        console.log('Context menu regen:', endpoint, contextMenuAssetId);
        const res = await fetch(`/api/${endpoint}/${contextMenuAssetId}/regenerate-thumbnail`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ force: true })
        });
        console.log('Context menu response status:', res.status);
        const data = await res.json();
        console.log('Context menu response data:', data);
        
        if (res.ok && (data.status === 'rendered' || data.status === 'reindexed')) {
          showNotification('Thumbnail regenerated', 'success');
          // Refresh the right list
          if (contextMenuAssetType === 'pdf') {
            loadAssets();
          } else {
            load3dModels();
          }
        } else {
          console.error('Context menu regen failed:', res.status, data);
          showNotification(data.message || 'Thumbnail generation failed', 'error');
        }
      } catch (e) {
        console.error('Context menu regen exception:', e);
        showNotification('Thumbnail generation failed', 'error');
      }
    }
    
    // 
    // BREADCRUMB CONTEXT MENU FUNCTIONS (for info panel breadcrumbs)
    // 
    
    let breadcrumbContextPath = null;
    
    function showBreadcrumbContextMenu(e, folderPath) {
      e.preventDefault();
      e.stopPropagation();
      breadcrumbContextPath = folderPath;
      // Use clientX/clientY for viewport-relative positioning (works in modals)
      showContextMenu('breadcrumbContextMenu', e.clientX, e.clientY);
    }
    
    function breadcrumbContextNavigate() {
      document.getElementById('breadcrumbContextMenu').style.display = 'none';
      if (breadcrumbContextPath) {
        closeModal();
        navigateToFolder(breadcrumbContextPath);
      }
    }
    
    async function breadcrumbContextForceIndex() {
      document.getElementById('breadcrumbContextMenu').style.display = 'none';
      if (!breadcrumbContextPath) {
        showNotification('No folder selected', 'error');
        return;
      }
      
      // Convert relative folder path to absolute system path
      let path = breadcrumbContextPath;
      if (!path.startsWith('/')) {
        const root = contentType === '3d' ? '/content/3d-models' : '/content/pdfs';
        path = root + '/' + path;
      }
      
      console.log('Breadcrumb force index on path:', path);
      showNotification('Starting index of folder...', 'info');
      
      try {
        const res = await fetch('/api/index/directory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path, force: true, recursive: true })
        });
        const data = await res.json();
        
        if (res.ok) {
          showNotification(`Indexed: ${data.new || 0} new, ${data.update || data.updated || 0} updated`, 'success');
          // Refresh the appropriate content type
          if (contentType === 'pdf') {
            loadFolders();
            loadAssets();
          } else {
            load3dFolders();
            load3dModels();
          }
        } else {
          showNotification(data.error || 'Index failed', 'error');
        }
      } catch (e) {
        showNotification('Index failed: ' + e.message, 'error');
      }
    }
    
    async function breadcrumbContextForceThumbs() {
      document.getElementById('breadcrumbContextMenu').style.display = 'none';
      if (!breadcrumbContextPath) {
        showNotification('No folder selected', 'error');
        return;
      }
      
      showNotification('Queuing thumbnail regeneration...', 'info');
      
      try {
        const res = await fetch('/api/thumbnails/render/folder', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ folder: breadcrumbContextPath, force: true })
        });
        const data = await res.json();
        
        if (res.ok) {
          showNotification(`Queued: ${data.queued || data.rendered || 0} thumbnails`, 'success');
        } else {
          showNotification(data.error || 'Failed to queue thumbnails', 'error');
        }
      } catch (e) {
        showNotification('Failed: ' + e.message, 'error');
      }
    }
    
    async function breadcrumbContextShowStatus() {
      document.getElementById('breadcrumbContextMenu').style.display = 'none';
      // Reuse existing status modal
      contextMenuShowStatus();
    }
    
    function showNotification(message, type = 'info') {
      // Simple notification - could be enhanced with a toast system
      const colors = { info: '#4dabf7', success: '#40c057', error: '#ff6b6b' };
      const existing = document.querySelector('.notification-toast');
      if (existing) existing.remove();
      
      const toast = document.createElement('div');
      toast.className = 'notification-toast';
      toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 20px;
        background: ${colors[type]};
        color: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10001;
        animation: slideIn 0.3s ease;
      `;
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => toast.remove(), 4000);
    }
    
    // 
    // MODAL ACTION FUNCTIONS (called from info panel buttons)
    // 
    
    async function reindexModel(modelId) {
      showNotification('Re-indexing model...', 'info');
      try {
        const res = await fetch(`/api/models/${modelId}/reindex`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ force: true })
        });
        const data = await res.json();
        if (res.ok) {
          showNotification(`Re-indexed: ${data.status}`, 'success');
        } else {
          showNotification(data.error || 'Re-index failed', 'error');
        }
      } catch (e) {
        showNotification('Re-index failed: ' + e.message, 'error');
      }
    }
    
    async function regenerateThumbnail(modelId) {
      showNotification('Regenerating thumbnail...', 'info');
      try {
        const res = await fetch(`/api/models/${modelId}/regenerate-thumbnail`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ force: true })
        });
        console.log('Regenerate response status:', res.status);
        const data = await res.json();
        console.log('Regenerate response data:', data);
        if (res.ok && data.status === 'rendered') {
          showNotification('Thumbnail regenerated', 'success');
          // Refresh the modal image
          const img = document.querySelector('.model-thumb-img');
          if (img) img.src = `/api/models/${modelId}/preview?t=${Date.now()}`;
          
          // Refresh the grid thumbnail
          const gridImg = document.querySelector(`img[data-model-id="${modelId}"]`);
          if (gridImg) {
            gridImg.src = `/api/models/${modelId}/preview?t=${Date.now()}`;
          }
        } else {
          console.error('Regenerate failed:', res.status, data);
          showNotification(data.message || 'Thumbnail generation failed', 'error');
        }
      } catch (e) {
        console.error('Regenerate exception:', e);
        showNotification('Thumbnail generation failed: ' + e.message, 'error');
      }
    }
    
    async function reindexAsset(assetId) {
      showNotification('Re-indexing PDF...', 'info');
      try {
        const res = await fetch(`/api/assets/${assetId}/reindex`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ force: true })
        });
        const data = await res.json();
        if (res.ok) {
          showNotification(`Re-indexed: ${data.status || 'success'}`, 'success');
        } else {
          showNotification(data.error || 'Re-index failed', 'error');
        }
      } catch (e) {
        showNotification('Re-index failed: ' + e.message, 'error');
      }
    }
    
    async function regenerateAssetThumbnail(assetId) {
      showNotification('Regenerating thumbnail...', 'info');
      try {
        const res = await fetch(`/api/assets/${assetId}/regenerate-thumbnail`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ force: true })
        });
        const data = await res.json();
        if (res.ok) {
          showNotification('Thumbnail regenerated', 'success');
          // Refresh the modal image
          const img = document.querySelector('#modalBody img');
          if (img) img.src = `/api/assets/${assetId}/thumbnail?t=${Date.now()}`;
        } else {
          showNotification(data.message || 'Thumbnail generation failed', 'error');
        }
      } catch (e) {
        showNotification('Thumbnail generation failed: ' + e.message, 'error');
      }
    }
    
    // 
    // COLUMN BROWSER FOR INDEX DIRECTORY
    // 
    
    let columnBrowserSelection = null;
    let columnBrowserColumns = [];
    
    async function openIndexDirectoryPicker() {
      // Get enabled asset locations
      const enabledLocations = assetLocations.filter(l => l.enabled);
      
      if (enabledLocations.length === 0) {
        showNotification('No asset locations configured. Add one first.', 'error');
        return;
      }
      
      // Reset state
      columnBrowserSelection = null;
      columnBrowserColumns = [];
      document.getElementById('columnBrowserPath').textContent = 'Select an asset volume';
      document.getElementById('columnBrowserSelectBtn').disabled = true;
      document.getElementById('forceIndexCheckbox').checked = false;
      document.getElementById('regenThumbnailsCheckbox').checked = false;
      
      // Build first column with asset volumes
      const container = document.getElementById('columnBrowserColumns');
      container.innerHTML = '';
      
      let html = '<div class="column-browser-column">';
      html += '<div class="column-header">Asset Volumes</div>';
      
      enabledLocations.forEach((loc, idx) => {
        const icon = loc.asset_type === 'documents' ? '' : '';
        html += `
          <div class="column-item volume" onclick="selectColumnVolume(${idx}, '${escapeHtml(loc.path)}')" data-path="${escapeHtml(loc.path)}">
            <span class="icon">${icon}</span>
            <span class="name">${escapeHtml(loc.name)}</span>
            <span class="arrow"></span>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
      columnBrowserColumns = [{ type: 'volumes', element: container.firstChild }];
      
      // Show modal
      document.getElementById('columnBrowserModal').classList.add('active');
    }
    
    async function selectColumnVolume(idx, path) {
      // Clear selection from all items in first column
      document.querySelectorAll('.column-browser-column:first-child .column-item').forEach(el => {
        el.classList.remove('selected');
      });
      
      // Select this item
      event.currentTarget.classList.add('selected');
      
      // Remove columns after the first
      const container = document.getElementById('columnBrowserColumns');
      while (container.children.length > 1) {
        container.removeChild(container.lastChild);
      }
      columnBrowserColumns = [columnBrowserColumns[0]];
      
      // Load subdirectories
      await loadColumnDirectory(path, 1);
    }
    
    async function loadColumnDirectory(path, columnIndex) {
      columnBrowserSelection = path;
      document.getElementById('columnBrowserPath').textContent = path;
      document.getElementById('columnBrowserSelectBtn').disabled = false;
      
      try {
        const res = await fetch(`/api/browse-directory?path=${encodeURIComponent(path)}`);
        const data = await res.json();
        
        // Filter to only directories
        const directories = (data.entries || []).filter(e => e.type === 'directory');
        
        if (directories.length === 0) {
          // No subdirectories - that's fine, user can select this folder
          return;
        }
        
        // Create new column
        const container = document.getElementById('columnBrowserColumns');
        const column = document.createElement('div');
        column.className = 'column-browser-column';
        
        let html = '<div class="column-header">Subdirectories</div>';
        directories.forEach(dir => {
          const safePath = dir.path.replace(/'/g, "\\'");
          html += `
            <div class="column-item" onclick="selectColumnItem(this, '${safePath}', ${columnIndex})" data-path="${escapeHtml(dir.path)}">
              <span class="icon"></span>
              <span class="name">${escapeHtml(dir.name)}</span>
              <span class="arrow"></span>
            </div>
          `;
        });
        
        column.innerHTML = html;
        container.appendChild(column);
        columnBrowserColumns.push({ path, element: column });
        
        // Scroll to show new column
        container.scrollLeft = container.scrollWidth;
        
      } catch (e) {
        console.error('Failed to load directory:', e);
      }
    }
    
    async function selectColumnItem(element, path, columnIndex) {
      // Clear selection from siblings
      element.parentElement.querySelectorAll('.column-item').forEach(el => {
        el.classList.remove('selected');
      });
      element.classList.add('selected');
      
      // Remove columns after this one
      const container = document.getElementById('columnBrowserColumns');
      while (container.children.length > columnIndex + 1) {
        container.removeChild(container.lastChild);
        columnBrowserColumns.pop();
      }
      
      // Load subdirectories
      await loadColumnDirectory(path, columnIndex + 1);
    }
    
    function closeColumnBrowser() {
      document.getElementById('columnBrowserModal').classList.remove('active');
      columnBrowserSelection = null;
    }
    
    async function confirmColumnBrowserSelection() {
      if (!columnBrowserSelection) {
        showNotification('No directory selected', 'error');
        return;
      }
      
      const forceIndex = document.getElementById('forceIndexCheckbox').checked;
      const regenThumbnails = document.getElementById('regenThumbnailsCheckbox').checked;
      const path = columnBrowserSelection;
      
      closeColumnBrowser();
      showNotification(`Starting index of ${path}...`, 'info');
      
      try {
        // Run index
        const res = await fetch('/api/index/directory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            path: path, 
            force: forceIndex,
            recursive: true 
          })
        });
        const data = await res.json();
        
        if (res.ok) {
          showNotification(
            `Indexed: ${data.new || 0} new, ${data.update || 0} updated, ${data.skip || 0} skipped`,
            'success'
          );
          load3dFolders();
          load3dModels();
          
          // If thumbnail regen requested, queue it
          if (regenThumbnails) {
            showNotification('Queueing thumbnail regeneration...', 'info');
            try {
              const thumbRes = await fetch('/api/thumbnails/render/pending', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ limit: 500 })
              });
              const thumbData = await thumbRes.json();
              if (thumbRes.ok) {
                showNotification(
                  `Thumbnails: ${thumbData.rendered || 0} rendered, ${thumbData.failed || 0} failed`,
                  'success'
                );
              }
            } catch (te) {
              showNotification('Thumbnail render failed', 'error');
            }
          }
        } else {
          showNotification(data.error || 'Index failed', 'error');
        }
      } catch (e) {
        showNotification('Index failed: ' + e.message, 'error');
      }
    }
    
    async function forceIndexLocation(locId, path) {
      closeAllEditMenus();
      showNotification(`Force indexing ${path}...`, 'info');
      
      try {
        const res = await fetch('/api/index/directory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path, force: true, recursive: true })
        });
        const data = await res.json();
        
        if (res.ok) {
          showNotification(
            `Indexed: ${data.new || 0} new, ${data.update || 0} updated, ${data.skip || 0} skipped`,
            'success'
          );
          load3dFolders();
          load3dModels();
        } else {
          showNotification(data.error || 'Index failed', 'error');
        }
      } catch (e) {
        showNotification('Index failed: ' + e.message, 'error');
      }
    }
    
    async function forceRegenThumbnails(locId, path) {
      closeAllEditMenus();
      showNotification('Queueing thumbnail regeneration...', 'info');
      
      try {
        const res = await fetch('/api/thumbnails/render/pending', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ limit: 500 })
        });
        const data = await res.json();
        
        if (res.ok) {
          showNotification(
            `Thumbnails: ${data.rendered || 0} rendered, ${data.failed || 0} failed`,
            'success'
          );
        } else {
          showNotification('Thumbnail render failed', 'error');
        }
      } catch (e) {
        showNotification('Thumbnail render failed', 'error');
      }
    }
    
    async function showLocationStatus(locId) {
      closeAllEditMenus();
      contextMenuShowStatus();  // Reuse the existing function
    }
  </script>


</body>
</html>
